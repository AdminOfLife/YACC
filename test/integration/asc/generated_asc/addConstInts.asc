		# ASC code generated by Yet Another CMPUT415 Compiler.
		# May the Force be ever in your favour, Mr. Potter.
		# CMPUT 415 - Fall 2013


		# #######################################################

		# Pre-defined constants to follow

		# #######################################################

		# Make room on the stack for new const true.
		ADJUST 1
		# Push const val = 1 on stack, pop it into place.
		CONSTI 1
		POP 0[0]
		# Make room on the stack for new const false.
		ADJUST 1
		# Push const val = 0 on stack, pop it into place.
		CONSTI 0
		POP 1[0]
		# Make room on the stack for new const maxint.
		ADJUST 1
		# Push const val = 2147483647 on stack, pop it into place.
		CONSTI 2147483647
		POP 2[0]

		# #######################################################

		# Start of user program

		# #######################################################

		# End of pre-def, call MAIN
		CALL 1, MAIN_0
MAIN_0
		# Make room on the stack for new var i
		ADJUST 1

		# End of var decls, jump over any other proc or func decls
		GOTO MAIN_1


		# Start of program, functions, or procedure:
MAIN_1
		# Pushing address of i in preparation for assignment.
		PUSHA 0[1]
		# Perform addition of INTEGER (null) and INTEGER (null)
		# Pushing anonymous constant value of type INTEGER
		CONSTI 5
		# Pushing anonymous constant value of type INTEGER
		CONSTI 10
		ADDI
		# Assigning a value to i
		POPI
		# End of user-defined pgram
		STOP

		# #######################################################

		# Pre-defined ASC functions to follow

		# #######################################################

# ASC code for the predefined function abs(x)
# Works as follows: if x < 0, return x * (-1), else return x. 
# __abs_int, __abs_real work for ints and reals respectively

__abs_int	PUSH -3[0]		# push x onto stack
		CONSTI 0		# push 0 onto stack
		LTI			# if x < 0, push 1, else push 0
		IFZ __abs_pos		# x >= 0, just return x
		PUSH -3[0]		# x < 0, push it onto stack
		CONSTI -1		# push -1 onto stack
		MULI			# top of stack <-- x * (-1)
		POP -4[0]		# place x in ret value location in stack
		GOTO __abs_ret

__abs_real	PUSH -3[0]		# push x onto stack
		CONSTR 0.0		# push 0 onto stack
		LTR			# if x < 0 push 1, else push 0
		IFZ __abs_pos		# x >= 0, just return x
		PUSH -3[0]		# if x < 0, push it onto stack
		CONSTR -1.0		# push -1.0 onto stack
		MULR			# top of stack <-- x * (-1.0)
		POP -4[0]		# place x in ret value location in stack
		GOTO __abs_ret

__abs_pos	PUSH -3[0]		# x is positive, push it onto stack
		POP -4[0]		# place x in ret value location in stack
		GOTO __abs_ret	

__abs_ret	RET 0
# ASC implementation of char() function.
# From the expression x that shall be of integer-type, this function shall
# return a result of chartype that shall be the value whose
# oridnal number is equal to the value of the expression x, if such a character
# value exists.  It shall be an error if such a character value does not
# exist.
# It shall be true that chr(ord(ch)) = ch
__chr			PUSH -3[0]	# push ch onto stack
			CONSTI 256	# push max ascii val onto stack
			GTI
			IFNZ __chr_err	# ch < 256 => not a char value
			PUSH -3[0]
			POP -4[0]	# return ch since we're using ascii
			RET 0

__chr_err		# PRINT ERROR MESSAGE
			STOP


###############################################################################
# __do_array_assignment : 
# Given two addresses which reference the base addresses of arrays and the
# size of the arrays (both arrays of the same size), __do_array_assignment
# copies the values from one array into the other. 
# Parameters:
#		-5[0] : &x, the address of the array which is receiving values
#		-4[0] : &y, the address of the array which is assigning values
#		-3[0] : the size of the array
###############################################################################

__do_array_assignment
			ADJUST 1		# make num of chars to read a
						# local variable
			PUSH -3[0]
			POP 0[0]
		
			# 1[0] will be the address to which we are trying
			# to assign a new value
			ADJUST 1
			PUSH -5[0]
			POP 1[0]

			# 2[0] will be the address which stores the value
			# we want to assign to 1[0]
			ADJUST 1
			PUSH -4[0]
			POP 2[0]

__do_loop	
			PUSH 0[0]		# top of stack <-- num of chars
						# left to read
			IFZ __do_done		
			# else, we have more values to assign  
			
			# first push the lastest &x
			PUSH 1[0]
			# push the lastest &y
			PUSH 2[0]
			# replace &y with *y on the stack
			PUSHI
			# store the value *y at &x
			POPI

			# increment the addresses
			PUSH 1[0]
			CONSTI 1
			ADDI
			POP 1[0]

			PUSH 2[0]
			CONSTI 1
			ADDI
			POP 2[0]

			# decrement the counter
			PUSH 0[0]
			CONSTI -1
			ADDI
			POP 0[0]
		# do next iteration
			GOTO __do_loop
__do_done	
			!D
			# kick local vars off the stack
			ADJUST -3
			# go away
			RET 0

################################################################################
# __do_str_eq_op():
# Given two strings (e.g., array of chars, strings literals are formatted/saved
# such that in these functions the two are indistinguishable), determines
# if they are exactly equal.
# Parameters
#		-3[0] n : the size of strings to be compared
#		-4[0] y : the RHS operand in the equality operation, an address
#		-5[0] x : the LHS operand in the equality operation, an address
################################################################################

__do_str_eq_op
		# nothing to set up, let's get to it

__do_str_eq_loop
			PUSH -3[0]	# push n onto the stack
			IFZ __do_str_eq_true
			# else, we have more comparasons to do
			PUSH -4[0]
			PUSHI
			PUSH -5[0]
			PUSHI
			EQI 
			IFNZ __do_str_eq_false

			# increment &y
			PUSH -4[0]
			CONSTI 1
			ADDI
			POP -4[0]

			# increment &x
			PUSH -5[0]
			CONSTI 1
			ADDI 
			POP -5[0]

			# decrement n
			PUSH -3[0]
			CONSTI -1
			ADDI
			POP -3[0]

			# do next iteration
			goto __do_str_eq_loop

__do_str_eq_true
			CONSTI 1
			POP -5[0]	# save over last param as we
					# have no expectation that caller
					# allocated ret val memory
			GOTO __do_str_eq_ret
__do_str_eq_false
			CONSTI 0
			POP -5[0]

__do_str_eq_ret		RET 0 
				

################################################################################
# __do_str_lt_op()
# You know the drill.
# Parameters
#		-3[0] n : the size of the strings to be compared
#		-4[0] y : the RHS operand
#		-5[0] x : the LHS operand
################################################################################

__do_str_lt_op
			# nothing to set up

__do_str_lt_loop
			PUSH -3[0]	# push n onto the stack
			IFZ __do_str_lt_false
			
			# push *y
			PUSH -4[0]
			PUSHI

			# push *x
			PUSH -5[0]
			PUSHI

			# test *x < *y, if yes, we return true
			LTI
			IFNZ __do_str_lt_true

			# push *y
			PUSH -4[0]
			PUSHI

			# push *x
			PUSH -5[0]
			PUSHI

			# test *x == *y, if yes we set up next iteration
			EQI
			IFNZ __do_str_lt_cont

			# else it must be that *x > *y, so we return false
			GOTO __do_str_lt_false


__do_str_lt_cont
			# set up next iteration
			# increment &y
			PUSH -4[0]
			CONSTI 1
			ADDI
			POP -4[0]
		
			# increment &x
			PUSH -5[0]
			CONSTI 1
			ADDI
			POP -5[0]

			# decrement n
			PUSH -3[0]
			CONSTI -1
			ADDI 
			POP -3[0]
			GOTO __do_str_lt_loop	


__do_str_lt_true
			CONSTI 1
			POP -5[0]
			GOTO __do_str_lt_ret

__do_str_lt_false
			CONSTI 0
			POP -5[0]
__do_str_lt_ret
			RET 0	


################################################################################
# ASC implementation of the exponential funcion.
################################################################################

			# if x is an int, we simply raise e to the power x
__exp_int		CONSTI 0		# make room for return value	
			PUSH -3[0]		# push x onto the stack
			CONSTR 2.7182818284	# push ~e onto stack
			CALL 0, __pow_real_int	# raise e to the power x
			ADJUST -2		# kick params off the stack
		
			POP -4[0]
			RET 0

__exp_real		CONSTI 0
			PUSH -3[0]
			CALL 0, __is_bad_real
			ADJUST -1
			IFNZ __exp_err

			CONSTR 10.0	# if x > 10, call __exp_large_x to 
					# handle it
			PUSH -3[0]
			LTR		# test x > 10.0
			IFNZ __exp_large_x
			ADJUST 4	# make room for k, k!, x^k, and sum
					# so far
			CONSTI 35	# we can only calculate up to 35
					# summands as 36! is not representable
					# in ASC (it is too large)
			POP 0[0]
			CONSTR 0.0
			POP 3[0]
			GOTO __exp_loop


__exp_loop		PUSH 0[0]
			CONSTI -1
			ADDI
			POP 0[0]
			PUSH 0[0]
			CONSTI 0
			LTI
			IFNZ __exp_done
			
			# calculate k!
			CONSTI 0
			PUSH 0[0]
			CALL 0, __factorial
			ADJUST -1
			POP 1[0]

			# calculate x^k
			CONSTI 0
			PUSH 0[0]
			PUSH -3[0]
			CALL 0, __pow_real_int
			ADJUST -2
			POP 2[0]

			# calculate next summand
			PUSH 2[0]
			PUSH 1[0]
			DIVR
			PUSH 3[0]
			ADDR
			POP 3[0]
			GOTO __exp_loop
			

__exp_err		# print error message
			STOP

__exp_done		PUSH 3[0]
			POP -4[0]
			ADJUST -4
			RET 0

# If x is particularily large we need a special method to compute its value
# as the method above converges slowly and returns bad resuls for even modest
# values of x (e.g., > 50).
__exp_large_x		ADJUST 4		# make room for n, x-n, e^n, and
						# e^(x-n) 	
			PUSH -3[0]		# push x onto the stack
			RTOI			# truncate it by converting it
						# to an integer
			POP 0[0]		# store n back into stack
			# calculate x-n
			PUSH -3[0]		# push n, x onto the stack
			PUSH 0[0]
			ITOR
			SUBR			# top of stack <-- x-n
			POP 1[0]		# save this value back in stack
			# now we get e^n
			CONSTI 0		# make room for ret value
			PUSH 0[0]
			CALL 0, __exp_int	
			ADJUST -1
			POP 2[0]
					
	
			# now we get e^(x-n)
			CONSTI 0
			PUSH 1[0]
			CALL 0, __exp_real
			ADJUST -1
			POP 3[0]

			# calculate final value
			PUSH 3[0]
			PUSH 2[0]
			MULR
			POP -4[0]
			ADJUST -4
			RET 0

###############################################################################
# factorial(n) - returns n! (useful in calculating values of trig functions)
# --> returns the n! as a real such that we can express larger factorial values
###############################################################################
__factorial		ADJUST 1	# make room for local var tmp
			PUSH -3[0]	# push n onto stack
			IFZ __factorial_zero #handle special case n = 0
			PUSH -3[0]	# push n onto stack
			ITOR		# make n a real
			POP -3[0]	# save n as a real
			PUSH -3[0]	# put n onto stack
			POP 0[0]	# tmp <-- n
			GOTO __factorial_loop

__factorial_zero	CONSTR 1.0
			POP 0[0]
			GOTO __factorial_done

__factorial_loop	PUSH -3[0]	# push n onto stack
			CONSTR -1.0	# push -1 onto stack
			ADDR		# top of stack <-- n - 1
			POP -3[0]	# n <-- n - 1
			PUSH -3[0]	# push n-1 onto stack
			IFZ __factorial_done
			PUSH -3[0]	# push n-1 onto stack
			PUSH 0[0]	# push tmp onto stack
			MULR		# top of stack <-- tmp * (n - 1)
			# TODO: add test for > maxint, set run-time error 
			POP 0[0]	# tmp <-- tmp * (n - 1)
			GOTO __factorial_loop


__factorial_done	PUSH 0[0]	# push tmp onto stack
			POP -4[0]	# save tmp as ret value
			ADJUST -1	# kick local vars off stack
			GOTO __factorial_ret

__factorial_ret		RET 0
# Returns true if the given real is nan, +inf or -inf.
# Returns otherwise.
__is_bad_real	PUSH -3[0]
		RTOI
		CONSTI 2146435072	# push nan onto stack
		RTOI
		EQI
		IFNZ __is_bad_real_true
		PUSH -3[0]
		RTOI
		CONSTI 2139095040	# push +inf onto stack
		RTOI
		EQI
		IFNZ __is_bad_real_true
		PUSH -3[0]
		RTOI
		CONSTI -8388608		# push -inf onto stack
		RTOI
		EQI
		IFNZ __is_bad_real_true
		CONSTI 0
		POP -4[0]
		GOTO __is_bad_real_ret

__is_bad_real_true	CONSTI 1
			POP -4[0]
			GOTO __is_bad_real_ret

__is_bad_real_ret	RET 0

__ln_int		PUSH -3[0]
			ITOR
			POP -3[0]
			GOTO __ln_real

__ln_real		PUSH -3[0]
			CONSTR 0.0
			EQR
			IFNZ __ln_err
			PUSH -3[0]
			CONSTR 0.0
			LTR
			IFNZ __ln_err
			# x has been validated, let's start calculating
			# ln(x)'s Taylor series
			ADJUST 7	# make room for local vars
			# 0[0] = k -> summation index
			CONSTI 7
			POP 0[0]
			# 0[1] = (-1)^(k+1) 
			CONSTR 0.0
			POP 1[0]
			# 2[0] = (x - 1)^k
			CONSTR 0.0
			POP 2[0]
			# 3[0] = sum so far
			CONSTR 0.0
			POP 3[0]
			# test if x < 1
			PUSH -3[0]
			CONSTR 1.0
			LTR
			IFNZ __ln_increase_arg
			GOTO __ln_reduce_arg
			# offsets 4,5,6 will store m, exp(m) and x*exp(-m) 
			# where m in the smallest integer such that
			# x < exp(m)  

			# x < 1, so we have to bring it back into the range
			# that which we can handle
__ln_increase_arg	CONSTI 0
			POP 4[0]	# our initial guess for -m is 0
			GOTO __ln_increase_aarg_loop


__ln_increase_aarg_loop #!D 
			CONSTI 0	# make room for ret value
			PUSH 4[0]	# push -m onto stack
			CALL 0, __exp_int
			#!D
			ADJUST -1	
			POP 5[0]	# save exp(-m) into the stack
			#!D
			PUSH 5[0]	# push exp(-m)
			PUSH -3[0]	# push x onto stack
			#!D
			LTR		# test x > exp(-m)
			#!D
			IFNZ __ln_loop_prep
			# else decrement m and try again
			PUSH 4[0]
			CONSTI -1
			ADDI
			POP 4[0]
			GOTO __ln_increase_aarg_loop


			# x > 2, so we have to bring it back into the range
			# that we can handle
__ln_reduce_arg		CONSTI 0
			POP 4[0]	# our initial guess for m is 0
			GOTO __ln_reduce_arg_loop

__ln_reduce_arg_loop	CONSTI 0	# make room for ret value
			PUSH 4[0]	# push m onto stack
			CALL 0, __exp_int	# calculate exp(m)
			ADJUST -1	# top of stack <-- exp(m)
			POP 5[0]	# save exp(m) into stack
			PUSH 5[0]	# push exp(m) onto stack
			PUSH -3[0]	# push x onto stack
			GTR		# test x < exp(m)
			IFNZ __ln_loop_prep
			# else increment m and try again
			PUSH 4[0]
			CONSTI 1
			ADDI
			POP 4[0]
			GOTO __ln_reduce_arg_loop

__ln_loop_prep		#!D
			# correct m value found, we calculate x*exp(-m)
			# which the value we use use as y in the expression
			# ln(y) which is calculated by Taylor expansion
			CONSTI 0			
			PUSH 4[0]
			CONSTI -1
			MULI
			CALL 0, __exp_int
			ADJUST -1
			PUSH -3[0]
			MULR
			POP 6[0]
			GOTO __ln_loop
			

__ln_loop		PUSH 0[0]	# push k onto stack and decrement
			CONSTI -1	
			ADDI		# top of stack <- k-1
			POP 0[0]	# save k-1 as new k value
			PUSH 0[0]	# push k onto stack
			CONSTI 0	
			EQI		# test k == 0
			IFNZ __ln_done

			# first calculate (-1)^k+1
			CONSTR 0.0	# make room for return value
			PUSH 0[0]
			CONSTI 1	# top of stack <-- k+1	
			ADDI
			CONSTI -1 
			CALL 0, __pow_int_int
			ADJUST -2	# kick params off stack
			POP 1[0]	# save (-1)^(k+1) back into stack

			# next calculate (x-1)^k
			CONSTR 0.0	# make room for ret
			PUSH 0[0]	# push k
			PUSH 6[0]
			CONSTR -1.0
			ADDR		# top of stack <-- x-1
			CALL 0, __pow_real_int
			ADJUST -2	# kick params off stack
			POP 2[0]	# save value back into stack

			# ready to calculate next summand
			PUSH 1[0]	# push (-1)^(k+1)
			PUSH 0[0]	# push k onto the stack
			ITOR
			DIVR		# top of stack <-- ((-1)^(k+1)) / k
			PUSH 2[0]	# push (x-1)^k onto the stack
			MULR		# top of stack <-- kth summand
			PUSH 3[0]	# push sum so far onto stack
			ADDR
			POP 3[0]	# save kth summand + sum so far
			GOTO __ln_loop

__ln_err		#TODO print error message
			STOP

__ln_done		PUSH 3[0]
			PUSH 4[0]
			ITOR
			ADDR
			POP -4[0]	# save sum as return value
			ADJUST -7	# kick local vars off stack
			RET 0




# ASC code for the predefined function odd(x)
# Definition (from standard):
# From the expression x that shall be of integer-type, this function shall be
# equivalent to the expression
# 	(abs(x) mod 2 = 1) (note abs(s) not necessary, x = -x mod 2 for all x)

__odd:		PUSH -3[0]		# push x onto the top of the stack
		CONSTI 2		# push 2 onto the top of the stack
		MOD			# top of stack <-- x mod 2
		POP -4[0]		# place result in the section of the 
					# stack reservered for return values
		RET 0			# pop the 0th display register frame
# ASC implementation of the ord() function.
# From the expression x that shall be of an ordinal-type, this function shall
# return a result of integer-type that shall be the ordinal number of the value
# of the expression x.
#
# For us this is really easy: all ordinal types are represented as ints,
# so we literally just return the value we were given.  Fantastic.
__ord		PUSH -3[0]
		POP -4[0]
		RET 0
#
# Not a pre-defined function, but a helpful one with calculations used 
# in other pre-defined functions.
# Takes as args x, n (n always int) and return x^n as a real
#
__pow_int_int		PUSH -3[0]	# push x onto stack
			ITOR		# convert it to a real
			POP -3[0]	# place it in param 1 location in stack
			GOTO __pow_real_int

__pow_real_int		PUSH -4[0]	# push n onto stack
			IFZ __pow_zeroexp	# n = 0, return 1
			PUSH -3[0]	# push x onto stack
			IFZ __pow_zerobase
			PUSH -4[0]	# push n onto stack
			CONSTI 0	# test n < 0
			LTI
			IFNZ __pow_neg	# handle special case x < 0
			# else, nonzero base and exp and we have work to do
			ADJUST 1	# make room on stack for tmp
			PUSH -3[0]	# push x onto stack
			POP 0[0]	# store tmp <-- x, tmp will be used
					# as rolling value as we continually
					# multiply x by itself
			GOTO __pow_real_int_loop

__pow_neg		ADJUST 1
			CONSTR 1.0
			PUSH -3[0]
			DIVR
			POP 0[0]
			# now we make n positive for easier looping
			PUSH -4[0]
			CONSTI -1
			MULI
			POP -4[0]
			GOTO __pow_neg_loop

__pow_neg_loop		PUSH -4[0]	# n > 0, so decrement it
			CONSTI -1
			ADDI
			POP -4[0]	# n <-- n - 1
			PUSH -4[0]	#push n onto stack
			IFZ __pow_neg_done
			PUSH 0[0]	# push tmp onto stack
			PUSH -3[0]	# push onto stack
			DIVR		# top of stack <-- tmp  x
			POP 0[0]	# store result as new tmp
			GOTO __pow_neg_loop

__pow_neg_done		PUSH 0[0]	# put tmp on top of stack
			POP -5[0]	# save tmp as ret value
			ADJUST -1	# kick local vars off stack
			GOTO __pow_ret

__pow_real_int_loop	PUSH -4[0]	# n > 0, so decrement it
			CONSTI -1
			ADDI
			POP -4[0]	# n <-- n - 1
			PUSH -4[0]	#push n onto stack
			IFZ __pow_real_int_done
			PUSH 0[0]	# push tmp onto stack
			PUSH -3[0]	# push onto stack
			MULR		# top of stack <-- tmp * x
			POP 0[0]	# store result as new tmp
			GOTO __pow_real_int_loop

__pow_real_int_done	PUSH 0[0]	# put tmp on top of stack
			POP -5[0]	# save tmp as ret value
			ADJUST -1	# kick local vars off stack
			GOTO __pow_ret

__pow_zeroexp		CONSTR 1.0	# push 1.0 onto stack
			POP -5[0]	# place 1.0 in ret val location in stack
			GOTO __pow_ret

__pow_zerobase		CONSTR 0.0	# push 0.0 onto stack
			POP -5[0]	# place 0.0 in ret val location in stack
			GOTO __pow_ret

__pow_ret		RET 0

# ASC implementation of the function pred()
# From the expression x that shall be of an ordinal-type, this function shall
# return a result that shall be of the same type as that of the expression.
# The function shall yield a value whose ordinal number is one less that that
# of the expression x, if such a value exists.  It shall be an error if such a
# a value does not exist.


# __pred for integers #########################################################
__pred_int		PUSH -3[0]	# push x onto the stack
			# TODO: test if == minint
			CONSTI -1	# push -1 onto stack
			ADDI		# x <-- x-1
			POP -4[0]	# save x-1 as ret value
			RET 0	
__pred_error		# value passed == minint, no predecessor
			STOP


# __pred for booleans #########################################################

__pred_bool		PUSH -3[0]	# push x onto the stack
			CONSTI 1	# push 1 onto the stack
			EQI		# if x != 1, has no predecessor
			IFZ __pred_bool_err
			CONSTI 0	# else, save 0 as ret value
			POP -4[0]
			RET 0

__pred_bool_err		# no predecessor
			STOP

# __pred for scalar enumerations ##############################################

__pred_scalar		PUSH -3[0]	# test if x == 0
			CONSTI 0
			EQI
			IFNZ __pred_scalar_err	# x == 0, error
			PUSH -3[0]	# if not, then decrement and return
			CONSTI -1
			ADDI
			POP -4[0]
			RET 0

__pred_scalar_err	# no predecessor
			STOP

# __pred for chars ############################################################
__pred_char		PUSH -3[0]	# test if x == 0
			CONSTI 0
			EQI
			IFNZ __pred_char_err	# x == 0, error
			PUSH -3[0]	# if not, then decrement and return
			CONSTI -1
			ADDI
			POP -4[0]
			RET 0

__pred_char_err	# no predecessor
			STOP
			
# ASC implementation of read()
# Calling convention:
#	- for ints and real, just push param as usual (i.e., param is the 
#	  address where the value read in is to be placed)
#	- for chars/strs, first param is the number of chars to read (e.g.,
#	  if we want to read(s) where s : array[1..10] of char, then the first
#	  param should be 10 and read() will assume -13[0] is the address
#	  into which to return the first char read (e.g., s[1])
# NOTE: check err flag after reading from input, if it does not get the type
# it is expecting then it is a run time error and the program will halt.
__read_str		ADJUST 1	# make # of chars to read a local var
			PUSH -3[0]	
			POP 0[0]
			GOTO __read_str_loop

__read_str_loop		PUSH 0[0]	# top of stack <-- # char left to read
			IFZ __read_str_done
			# else we have more chars to read
			PUSH -4[0]	# push &x	
			READC		# get char from stdin
			IFERR __read_str_err 
			POPI 		# store read char at &x
			# decrement # of chars left to print
			PUSH 0[0]
			CONSTI -1
			ADDI
			POP 0[0]
			# increment address
			PUSH -4[0]
			CONSTI 1
			ADDI
			POP -4[0]
			GOTO __read_str_loop

__read_str_done		ADJUST -1
			RET 0

__read_str_err		CONSTI 90	# TODO: print real error message
			WRITEC
			STOP



__read_int		PUSH -3[0]	# push &x onto stack
			READI		# read int from stdin
			IFERR __read_int_err
			POPI		# pop value read from stdin to
					# address specified by param
			RET 0		
			

__read_int_err		# TODO: produce error message
			CONSTI 90
			WRITEI
			STOP

__read_real		PUSH -3[0]	# push &x onto stack
			READR		# read real from stdin
			IFERR __read_real_err
			POPI		# pop value read from stdin to addr
					# specified by param
			RET 0		

__read_real_err		STOP 		# TODO print error

__read_no_args
			READC
			ADJUST -1
			RET 0
# ASC implementation of readln()
# Calling convention:
#	- for ints and real, just push param as usual (i.e., param is the 
#	  address where the value read in is to be placed)
#	- for chars/strs, first param is the number of chars to read (e.g.,
#	  if we want to readln(s) where s : array[1..10] of char, then the first
#	  param should be 10 and readln() will assume -13[0] is the address
#	  into which to return the first char read (e.g., s[1])
# NOTE: check err flag after reading from input, if it does not get the type
# it is expecting then it is a run time error and the program will halt.

__readln_str		ADJUST 1	# make # of chars to read a local var
			PUSH -3[0]	
			POP 0[0]
			GOTO __readln_str_loop

__readln_str_loop	PUSH 0[0]	# top of stack <-- # char left to read
			IFZ __readln_str_done
			# else we have more chars to read
			PUSH -4[0]
			READC		# get char from stdin
			IFERR __readln_str_err 
			DUP		# push extra copy of read in char onto
					# stack as we need to test it for
					# equality with newline
			CONSTI 10	# ascii val of newline char
			EQI		# see read in char == newline
			IFNZ __readln_str_nl_done
			POPI 		# store read char at &x

			# decrement # of chars left to print
			PUSH 0[0]
			CONSTI -1
			ADDI
			POP 0[0]

			# increment &x
			PUSH -4[0]
			CONSTI 1
			ADDI
			POP -4[0]
			GOTO __readln_str_loop

__readln_str_nl_done	# stopped reading because we caugh a newline, so
			# we have two extra values on stack we need to kick off
			ADJUST -2
			GOTO __readln_str_done

__readln_str_done	ADJUST -1
			CONSTI 10
			WRITEC
			RET 0

__readln_str_err	CONSTI 90	# TODO: print real error message
			WRITEC
			STOP

__readln_int		PUSH -3[0]	# push &x onto stack
			READI		# read int from stdin
			IFERR __readln_int_err
			POPI		# pop value read from stdin to
					# address specified by param
			READC		# consume newline
			WRITEC
			RET 0		
			

__readln_int_err	# TODO: produce error message
			CONSTI 90
			WRITEI
			STOP

__readln_real		PUSH -2[0]	# push &x onto stack
			READR		# read real from stdin
			IFERR __readln_real_err
			POPI		# pop value read from stdin to addr
					# specified by param
			READC		# consume newline
			WRITEC
			RET 0		

__readln_real_err	STOP 		# TODO print error



# ASC implementation of round()
# From the expression x that shall be of real-type, this function shall return
# a result of integertype.  If x is positive or zero, round(x) shall be 
# equivalent to trunc(x + 0.5) ; otherwise, round(x) shall be equivalent to
# trunc(x - 0.5).  It shall be an error if such a value does not exist.  It
# shall be an error if such a value does not exist.
# TODO: check for error in case of x = inf or x = nan
__round			PUSH -3[0]
			CONSTR 0.0
			GTR
			IFNZ __round_pos
			PUSH -3[0]
			CONSTR 0.0
			EQR
			IFNZ __round_zero
			GOTO __round_neg

__round_pos		CONSTI 0	# make room for ret on stack
			PUSH -3[0]
			CONSTR 0.5	
			ADDR		# x <-- x + 0.5
			CALL 0, __trunc
			ADJUST -1	# kick param off the stack
			POP -4[0]	# make ret val from trunc() our ret val
			GOTO __round_ret

__round_zero		CONSTI 0	# x == 0.0, return int 0
			POP -4[0]
			GOTO __round_ret

__round_neg		CONSTI 0	# make room for ret val on stack
			PUSH -3[0]
			CONSTR -0.5
			ADDR
			CALL 0, __trunc
			ADJUST -1	# kick param off the stack
			POP -4[0]	# make ret val from trunc() our ret val
			GOTO __round_ret

__round_ret		RET 0

###############################################################################
# sin(x) - returns the value of the sine of x where x is in radians.
# We're going to approximate the value of sine by calculating "enough" terms
# of its Taylor series.
###############################################################################

__sin_int		PUSH -3[0]	# push x onto stack
			ITOR		# conver to real
			POP -3[0]	# push into param slot
			GOTO __sin_real	# "call" real valued version of sin()

__sin_real		CONSTI 0
			PUSH -3[0]
			CALL 0, __is_bad_real
			ADJUST -1
			IFNZ __exp_err		

			ADJUST 1	# make room for k = summation index
					# in the taylor series for sine
			CONSTI 6	# We are going to sum the first 6
					# series
			POP 0[0]

			ADJUST 1	# make room for (-1)^k
			CONSTR 0.0	
			POP 1[0]	# set (-1)^k = 0 for now

			ADJUST 1	# make room for (2k + 1)!
			CONSTR 0.0
			POP 2[0]	# set it to zero for now

			ADJUST 1	# make room for x^(2k+1) and set to 0
			CONSTR 0.0
			POP 3[0]

			# make room for value of sum so far, set to 0
			ADJUST 1	
			CONSTR 0.0
			POP 4[0]

			GOTO __sin_loop

__sin_loop		PUSH 0[0]	# push k onto stack
			CONSTI -1	# push -1 onto stack
			ADDI		# k <- k-1
			POP 0[0]	# save new value of k
			PUSH 0[0]	# push k onto stack
			CONSTI 0	# push 0 onto stack
			LTI
			IFNZ __sin_done	# k < 0 => we are done
			# else, we calculate the next summand

			#first calculate (-1)^k, make call to __pow_int_int
			CONSTR 0.0	# make room for ret value
			PUSH 0[0]	# push k as second param
			CONSTI -1	# push -1 as first param
			CALL 0, __pow_int_int
			ADJUST -2	# kick params off the stack
			POP 1[0]	# save (-1)^k back into local vars

			#next calculate (2k + 1)!
			CONSTR 0.0	# make room for ret value
			PUSH 0[0]	# push k onto stack
			CONSTI 2	# push 2 onto stack
			MULI		# top of stack <-- 2*k
			CONSTI 1	# push 1 onto stack
			ADDI		# top of stack <-- 2*k + 1
			CALL 0, __factorial
			ADJUST -1	# kick param off stack
			POP 2[0]	# save (2k+1)! back into local vars

			# next we calculate x^(2k+1)
			CONSTR 0.0	# make room for ret value
			PUSH 0[0]	# push k onto stack
			CONSTI 2	# push 2 onto stack
			MULI		# top of stack <-- 2*k
			CONSTI 1	# push 1 onto stack
			ADDI		# top of stack <-- 2k+1
			PUSH -3[0]	# push x onto stack
			CALL 0, __pow_real_int
			ADJUST -2	# kick local vars off the stack
			POP 3[0]	# save val back into local vars

			# we're finally ready to calculate the summand
			PUSH 1[0]	# push (-1)^k
			PUSH 2[0]	# push (2k + 1)!
			DIVR		# top of stack <-- (-1)^k/(2k+1)!
			PUSH 3[0]	# push x^(2k+1)
			MULR		# top of stack <-- summand
			PUSH 4[0]	# push sum so far onto stack
			ADDR		# add summand to sum so far
			POP 4[0]	# save sum so far
			GOTO __sin_loop

__sin_done		PUSH 4[0]	# push sum so far onto stack
			POP -4[0]	# save it as ret value
			ADJUST -5	#kick local vars off the stack
			GOTO __sin_ret
__sin_ret		RET 0


# ASC implementation of the function sqr.
# square of x
# It shall be an error if such a value does not exist.
# TODO: insure all errors are caught (NOT THE CASE RIGHT NOW)
__sqr_int	PUSH -3[0]		# push x onto stack
		PUSH -3[0]		# push x onto stack (again)
		MULI			# top of stack <-- x * x
		GOTO __sqr_ret

__sqr_real	CONSTI 0
		PUSH -3[0]
		CALL 0, __is_bad_real
		IFNZ __sqr_err
		PUSH -3[0]
		PUSH -3[0]
		MULR
		GOTO __sqr_ret

__sqr_err	# print error message
		RET 0

__sqr_ret	POP -4[0]
		RET 0


# ASC implementation of the sqrt() function.
# non-negative square root of x, if x is not negative
# It shall be an error if x is negative.
# The standard specifies that sqrt() accepts both ints and reals, but always returns real.
# The strategy employed follows from en.wikipedia.org/wiki/Square_root
# To find sqrt(x), do:
#	-> start with arbitrary a, set a <-- (a + x/a)
#	-> keep iterating the value of a as give above, apparently you'll eventually get close
__sqrt_int		PUSH -3[0]		# push x onto stack
			ITOR			# convert it to a real
			POP -3[0]
			PUSH -3[0]
			GOTO __sqrt

__sqrt_real		PUSH -3[0]		# push x onto stack
			GOTO __sqrt

__sqrt			CONSTR 0.0		# push 0 onto stack, x now underneath 0
			LTR			# if x < 0 push 1, else push 0
			IFNZ __sqrt_err
						# x >= 0, if it's 0 let's not waste our time
						# computing
			PUSH -3[0]
			CONSTR 0.0
			EQR
			IFNZ __sqrt_ret		# if x == 0, we're done, else x > 0 and
						# we have work to do
			ADJUST 2		# make room for # of iters and a on stack
			CONSTI 10000		
			POP 0[0]		# number of iters <-- 10,000
			PUSH -3[0]
			CONSTR 2.0
			DIVR
			POP 1[0]		# initial guess for a = x / 2
			GOTO __sqrt_loop

__sqrt_loop		PUSH 0[0]		# push number of iters onto stack
			IFZ __sqrt_done		# if == 0, we're done
			PUSH 0[0]
			CONSTI -1
			ADDI			# else, decrement number of iters
			POP 0[0]		# and save it back in its place
			
			PUSH -3[0]		# push x onto stack
			PUSH 1[0]		# push a onto stack
			DIVR			# top of stack <-- x/a
			PUSH 1[0]		# push a onto stack
			ADDR			# top of stack <-- a + (x/a)
			CONSTR 2.0		# push 2.0 onto stack
			DIVR			# top of stack <- (a + (x/a))/2
			POP 1[0]		# a_new <-- stop of stack
			GOTO __sqrt_loop

__sqrt_done		ADJUST -2		# get rid of our local variables
			PUSH 1[0]		# put a onto stack
			GOTO __sqrt_ret

__sqrt_err		# print error message (write script to help do this stuff)
			STOP

__sqrt_ret		POP -4[0]
			RET 0

################################################################################
# __store_string_values() :
# Given an address which points to a contiguous chunk of heap memory of the
# the appropriate size, __store_string_value() stores the values which are 
# currently on the stack to the heap memory chunk.
# Parameters
#		-3[0] : n, the number of values to be stored
#		-4[0] through -(n+4)[0] : the values to be stored on the heap
#		    with the first value highest on the stack.
#		-(n+5)[0] : the base address of the contiguous heap section
################################################################################
__store_string_values
			ADJUST 1	# make num of values written to store a 
					# local param, hereby called x
			CONSTI 0	# and initialize it to zero
			POP 0[0]

			# now we get the address and make it a local param
			ADJUST 1
			PUSH -3[0]	# push n onto the stack
			CONSTI -1
			MULI		# top of stack <-- -n
			CONSTI -4	# adjust for other params
			ADDI
			PUSHI 0		# push the address onto the stack
			POP 1[0]	# and save it for later use

__store_loop
			PUSH 0[0] 	# push x onto stack
			PUSH -3[0]	# push n onto stack
			EQI		# determine if x == n
			IFNZ __store_done
		
			# else, we have more values to print
			# push next address onto stack
			PUSH 1[0]

			# calculate depth of xth parameter
			PUSH 0[0]
			CONSTI -1
			MULI
			CONSTI -4
			ADDI

			# push xth char onto the stack
			PUSHI 0

			# pop it off to the heap
			POPI

			# set up next iteration
			# increment x
			PUSH 0[0]
			CONSTI 1
			ADDI
			POP 0[0]

			# decrement address
			PUSH 1[0]
			CONSTI -1
			ADDI
			POP 1[0]

			# do next iteration
			GOTO __store_loop	

__store_done			
			# kick off local params
			ADJUST -2
			RET 0

# ASC implementation of the succ(x) function.
# From the expression x that shall be of an ordinal-type, this function shall
# return a result that shall be of the same type as that of the expression x.
# The function shall yield a value whose ordinal number is one greater than that
# of the expression x, if such a value exists.  It shall be an error if such a 
# value does not exist.
#

__succ_int		PUSH -3[0]	# push x onto the stack
			# TODO: make sure x < maxint
			CONSTI 1	# push 1 onto stack
			ADDI		# top of stack <-- x + 1
			POP -4[0]	# store x+1 as ret value
			RET 0				

__succ_int_err		# the integer give was == maxint, cannot get successor
			STOP

__succ_bool		PUSH -3[0]
			IFNZ __succ_bool_err	# bool > 0 => no successor
			CONSTI 1		# push 1 onto stack
			POP -4[0]		# make 1 ret value
			RET 0

__succ_bool_err		# print error message
			STOP

__succ_char		PUSH -3[0]	# push x onto stack
			CONSTI 255	# push ascii val of '9' onto stack
			EQI		# if x == '9', need ret = 'A', else
					# check if x is next boundary value 'Z' 
			IFNZ __succ_char_err
			PUSH -3[0]
			CONSTI 255
			GTI
			IFNZ __succ_char_err	# char with val >255 => no succ
			PUSH -3[0]
			CONSTI 1
			ADDI
			POP -4[0]
			RET 0

__succ_char_err 	# no successor
			STOP

# For scalar types we get to have even more fun.  Each item in an enumerated
# scalar type is represented internally as a const -- so that's easy to 
# increment.  The bit of extra work is that we need to also pass to succ() the
# largest value amongst the consts in the enumerated type (e.g., the number
# of elements in the enumerated scalara - 1, where we subtract 1 as the
# standard specifies that the values of the constants beings at 0).  This
# "largest" value will be passed as the second parameter to __succ_scalar
__succ_scalar		PUSH -3[0]	# push x onto the stack
			PUSH -4[0]	# push x_max onto the stack
			# We should only have to test for equality if we
			# are performing error checking correctly elsewhere
			# in the program
			EQI
			IFNZ __succ_scalar_err
			PUSH -3[0]
			CONSTI 1
			ADDI
			POP -5[0]
			RET 0
__succ_scalar_err	# print error message
			STOP



# Asc implementation of trunc()
# From the expression x that shall be of real-type, this function shall return
# a result of integerType.  The value of trunc(x) shall be such that if x is
# positive or zero, then 0 < x-trunc(x) < 1; otherwise -1 < x- trunc(x) < 0.
# It shall be an error if such a value does not exist.
# TODO: when can an error occur?
# NOTE: super easy, ROTI does trunc() for us.
__trunc		CONSTI 0
		PUSH -3[0]
		CALL 0, __is_bad_real
		ADJUST -1
		IFNZ __trunc_err
		PUSH -3[0]
		RTOI
		POP -4[0]
		RET 0

__trunc_err	# print err mesg
		STOP
# ASC implementation of write().
# HOW TO CALL:
#	-> For ints/reals, simply push param as usual and call.
#	-> For chrs/string, push number of chars to print as first param
#	    (i.e., at -3[0]), we then print the last param first (so 
#	    just throw everything onto the stack in the order you get it,
#	    then push number of params to print and then call write)
__write_str		ADJUST 1	# make number of args a local param
			PUSH -3[0]
			POP 0[0]
			GOTO __write_str_loop
__write_str_loop	PUSH 0[0]	# top of stack <-- # left to print
			IFZ __write_str_end	# nothing more to print, exit
			# else we have a char to write
			# start by calculating depth of 0[0]th param
			PUSH 0[0]
			CONSTI -1
			MULI		
			CONSTI -3
			ADDI
			PUSHI 0		# push next char onto stack
			WRITEC		# write the character
			# decrement # of args
			PUSH 0[0]
			CONSTI -1
			ADDI
			POP 0[0]
			GOTO __write_str_loop
__write_str_end		ADJUST -1	# kick local vars off the stack
			RET 0

__write_int		PUSH -3[0]
			WRITEI
			RET 0

__write_real		PUSH -3[0]
			WRITER
			RET 0


# ASC implementation of writeln.

__writeln_str		ADJUST 1	# make number of args a local param
			PUSH -3[0]
			POP 0[0]
			GOTO __writeln_str_loop
__writeln_str_loop	PUSH 0[0]	# top of stack <-- # left to print
			IFZ __writeln_str_end	# nothing more to print, exit
			# else we have a char to write
			# start by calculating depth of 0[0]th param
			PUSH 0[0]
			CONSTI -1
			MULI		
			CONSTI -3
			ADDI
			PUSHI 0		# push next char onto stack
			WRITEC		# write the character
			# decrement # of args
			PUSH 0[0]
			CONSTI -1
			ADDI
			POP 0[0]
			GOTO __writeln_str_loop
__writeln_str_end	ADJUST -1	# kick local vars off the stack
			CONSTI 10	# we're writeln, so we write newchar
					# before we go away
			WRITEC
			RET 0

__writeln_int		PUSH -3[0]
			WRITEI
			CONSTI 10
			WRITEC
			RET 0

__writeln_real		PUSH -3[0]
			WRITER
			CONSTI 10
			WRITEC
			RET 0

