
			GOTO test_start
#
# Not a pre-defined function, but a helpful one with calculations used 
# in other pre-defined functions.
# Takes as args x, n (n always int) and return x^n as a real
#
__pow_int_int		PUSH -3[0]	# push x onto stack
			ITOR		# convert it to a real
			POP -3[0]	# place it in param 1 location in stack
			GOTO __pow_real_int

__pow_real_int		PUSH -4[0]	# push n onto stack
			IFZ __pow_zeroexp	# n = 0, return 1
			PUSH -3[0]	# push x onto stack
			IFZ __pow_zerobase
			# else, nonzero base and exp and we have work to do
			ADJUST 1	# make room on stack for tmp
			PUSH -3[0]	# push x onto stack
			POP 0[0]	# store tmp <-- x, tmp will be used
					# as rolling value as we continually
					# multiply x by itself


__pow_real_int_loop	PUSH -4[0]	# n > 0, so decrement it
			CONSTI -1
			ADDI
			POP -4[0]	# n <-- n - 1
			PUSH -4[0]	#push n onto stack
			IFZ __pow_real_int_done
			PUSH 0[0]	# push tmp onto stack
			PUSH -3[0]	# push onto stack
			MULR		# top of stack <-- tmp * x
			POP 0[0]	# store result as new tmp
			GOTO __pow_real_int_loop

__pow_real_int_done	PUSH 0[0]	# put tmp on top of stack
			POP -5[0]	# save tmp as ret value
			ADJUST -1	# kick local vars off stack
			GOTO __pow_ret

__pow_zeroexp		CONSTR 1.0	# push 1.0 onto stack
			POP -5[0]	# place 1.0 in ret val location in stack
			GOTO __pow_ret

__pow_zerobase		CONSTR 0.0	# push 0.0 onto stack
			POP -5[0]	# place 0.0 in ret val location in stack
			GOTO __pow_ret

__pow_ret		RET 0



# ASC implementation of ln(x).
# We calculate ln(x) by, surprise, calculating sufficiently many summands
# in its Taylor series expansion about 0.

__ln_int		PUSH -3[0]
			ITOR
			POP -3[0]
			GOTO __ln_real

__ln_real		PUSH -3[0]
			CONSTR 0.0
			EQR
			IFNZ __ln_err
			PUSH -3[0]
			CONSTR 0.0
			LTR
			IFNZ __ln_err
			# x has been validated, let's start calculating
			# ln(x)'s Taylor series
			ADJUST 4	# make room for local vars
			# 0[0] = k -> summation index
			CONSTI 7
			POP 0[0]
			# 0[1] = (-1)^(k+1) 
			CONSTR 0.0
			POP 1[0]
			# 2[0] = (x - 1)^k
			CONSTR 0.0
			POP 2[0]
			# 3[0] = sum so far
			CONSTR 0.0
			POP 3[0]

			GOTO __ln_loop

__ln_loop		PUSH 0[0]	# push k onto stack and decrement
			CONSTI -1	
			ADDI
			POP 0[0]
			PUSH 0[0]
			CONSTI 0
			EQI
			IFNZ __ln_done
			# first calculate (-1)^k+1
			CONSTR 0.0	# make room for return value
			PUSH 0[0]
			CONSTI 1	# top of stack <-- k+1	
			ADDI
			CONSTI -1 
			CALL 0, __pow_int_int
			ADJUST -2	# kick params off stack
			POP 1[0]	# save (-1)^(k+1) back into stack

			# next calculate (x-1)^k
			CONSTR 0.0	# make room for ret
			PUSH 0[0]	# push k
			PUSH -3[0]
			CONSTR -1.0
			ADDR		# top of stack <-- x-1
			!D
			CALL 0, __pow_int_int
			!D	
			ADJUST -2	# kick params off stack
			POP 2[0]	# save value back into stack

			# ready to calculate next summand
			PUSH 1[0]	# push (-1)^(k+1)
			PUSH 0[0]	# push k onto the stack
			DIVR		# top of stack <-- ((-1)^(k+1)) / k
			PUSH 2[0]	# push (x-1)^k onto the stack
			MULR		# top of stack <-- kth summand
			PUSH 3[0]	# push sum so far onto stack
			ADDR
			POP 3[0]	# save kth summand + sum so far
			GOTO __ln_loop

__ln_err		#TODO print error message
			STOP

__ln_done		PUSH 3[0]
			POP -4[0]	# save sum as return value
			ADJUST -4	# kick local vars off stack
			RET 0

test_start		#!T=33330
			CONSTI 0
			CONSTR 1.2	# test with x = 1
			CALL 0, __ln_int
			!D
			STOP
			ADJUST -1
			WRITER
			CONSTI 10
			WRITEC
			CONSTI 0
			CONSTR 29.192	# test with x- 29.192
			CALL 0, __ln_real
			ADJUST -1
			WRITER
			
