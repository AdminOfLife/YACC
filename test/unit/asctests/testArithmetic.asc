# Blobbing the harder arithmetic functions together because they require
# the same helper functions.  This will be separated once the test runner
# is working properly.


# Helper function: takes int/real x as first param, int n as second, returns x^n
# TODO: in the future consider making the the O(lg(n)) version of exponentiation
# TODO: test for |x^n| > maxint, throw runtime error if that is the case
			GOTO test_start
__pow_int_int		PUSH -3[0]	# push x onto stack
			ITOR		# convert it to a real
			POP -3[0]	# place it in param 1 location in stack
			GOTO __pow_real_int

__pow_real_int		PUSH -4[0]	# push n onto stack
			IFZ __pow_zeroexp	# n = 0, return 1
			PUSH -3[0]	# push x onto stack
			IFZ __pow_zerobase
			# else, nonzero base and exp and we have work to do
			ADJUST 1	# make room on stack for tmp
			PUSH -3[0]	# push x onto stack
			POP 0[0]	# store tmp <-- x, tmp will be used
					# as rolling value as we continually
					# multiply x by itself


__pow_real_int_loop	PUSH -4[0]	# n > 0, so decrement it
			CONSTI -1
			ADDI
			POP -4[0]	# n <-- n - 1
			PUSH -4[0]	#push n onto stack
			IFZ __pow_real_int_done
			PUSH 0[0]	# push tmp onto stack
			PUSH -3[0]	# push onto stack
			MULR		# top of stack <-- tmp * x
			POP 0[0]	# store result as new tmp
			GOTO __pow_real_int_loop

__pow_real_int_done	PUSH 0[0]	# put tmp on top of stack
			POP -5[0]	# save tmp as ret value
			ADJUST -1	# kick local vars off stack
			GOTO __pow_ret

__pow_zeroexp		CONSTR 1.0	# push 1.0 onto stack
			POP -5[0]	# place 1.0 in ret val location in stack
			GOTO __pow_ret

__pow_zerobase		CONSTR 0.0	# push 0.0 onto stack
			POP -5[0]	# place 0.0 in ret val location in stack
			GOTO __pow_ret

__pow_ret		RET 0

###############################################################################
# factorial(n) - returns n! (useful in calculating values of trig functions)
###############################################################################
__factorial		ADJUST 1	# make room for local var tmp
			PUSH -3[0]	# push n onto stack
			IFZ __factorial_zero #handle special case n = 0
			PUSH -3[0]
			POP 0[0]	# tmp <-- n
			GOTO __factorial_loop

__factorial_zero	CONSTI 1
			POP 0[0]
			GOTO __factorial_done

__factorial_loop	PUSH -3[0]	# push n onto stack
			CONSTI -1	# push -1 onto stack
			ADDI		# top of stack <-- n - 1
			POP -3[0]	# n <-- n - 1
			PUSH -3[0]	# push n-1 onto stack
			IFZ __factorial_done
			PUSH -3[0]	# push n-1 onto stack
			PUSH 0[0]	# push tmp onto stack
			MULI		# top of stack <-- tmp * (n - 1)
			# TODO: add test for > maxint, set run-time error 
			POP 0[0]	# tmp <-- tmp * (n - 1)
			GOTO __factorial_loop


__factorial_done	PUSH 0[0]	# push tmp onto stack
			POP -4[0]	# save tmp as ret value
			ADJUST -1	# kick local vars off stack
			GOTO __factorial_ret

__factorial_ret		RET 0

###############################################################################
# sin(x) - returns the value of the sine of x where x is in radians.
# We're going to approximate the value of sine by calculating "enough" terms
# of its Taylor series.
###############################################################################

__sin_int		PUSH -3[0]	# push x onto stack
			ITOR		# conver to real
			POP -3[0]	# push into param slot
			GOTO __sin_real	# "call" real valued version of sin()

__sin_real		PUSH -3[0]	# push x onto stack

test_start		ADJUST 1
			CONSTI 0
			POP 0[0]
			CONSTI 0	# make room for ret
			CONSTI 2	# param n onto stack
			CONSTI 2	# param x onto stack
			CALL 0, __pow_int_int
			ADJUST -2	# kick params of stack
			WRITER		# write result
			CONSTI 10
			WRITEC
			
			# test with n = 10, x = 10.0
			CONSTI 0	# make room for ret
			CONSTI 10	# param n onto stack
			CONSTR 10.0	# param x onto stack
			CALL 0, __pow_real_int
			ADJUST -2	# kick params of stack
			WRITER		# write result
			CONSTI 10
			WRITEC

			# test with n = 4, x = -3.49
			# desk calculator says answer should be 148.354
			CONSTI 0	# make room for ret
			CONSTI 4	# param n onto stack
			CONSTR -3.49	# param x onto stack
			CALL 0, __pow_real_int
			ADJUST -2	# kick params of stack
			WRITER		# write result
			CONSTI 10
			WRITEC

			# test factorial(n) with n = 4
			CONSTI 0	# make room for ret
			CONSTI 4	# param n onto stack
			CALL 0,__factorial
			ADJUST -1	# kick params of stack
			WRITEI		# write result
			CONSTI 10
			WRITEC

			# test factorial(n) with n = 0
			CONSTI 0	# make room for ret
			CONSTI 0	# param n onto stack
			CALL 0,__factorial
			ADJUST -1	# kick params of stack
			WRITEI		# write result
			CONSTI 10
			WRITEC

			# test factorial(n) with n = 11
			# internet sez the value is 39916800
			CONSTI 0	# make room for ret
			CONSTI 11	# param n onto stack
			CALL 0,__factorial
			ADJUST -1	# kick params of stack
			WRITEI		# write result
			CONSTI 10
			WRITEC

			STOP
