/*
 * Pre-defined asc code emission.
 * This file is auto-generated. Do not edit it, but instead edit the
 * sourced __*.asc files.
 */

#include "PreDefAsc.h"

void emitPreDefAsc() {
	
emitStr(&stmts, "", "# ASC code for the predefined function abs(x)", "\n");
emitStr(&stmts, "", "# Works as follows: if x < 0, return x * (-1), else return x. ", "\n");
emitStr(&stmts, "", "# __abs_int, __abs_real work for ints and reals respectively", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__abs_int\tPUSH -3[0]\t\t# push x onto stack", "\n");
emitStr(&stmts, "", "\t\tCONSTI 0\t\t# push 0 onto stack", "\n");
emitStr(&stmts, "", "\t\tLTI\t\t\t# if x < 0, push 1, else push 0", "\n");
emitStr(&stmts, "", "\t\tIFZ __abs_pos\t\t# x >= 0, just return x", "\n");
emitStr(&stmts, "", "\t\tPUSH -3[0]\t\t# x < 0, push it onto stack", "\n");
emitStr(&stmts, "", "\t\tCONSTI -1\t\t# push -1 onto stack", "\n");
emitStr(&stmts, "", "\t\tMULI\t\t\t# top of stack <-- x * (-1)", "\n");
emitStr(&stmts, "", "\t\tPOP -4[0]\t\t# place x in ret value location in stack", "\n");
emitStr(&stmts, "", "\t\tGOTO __abs_ret", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__abs_real\tPUSH -3[0]\t\t# push x onto stack", "\n");
emitStr(&stmts, "", "\t\tCONSTR 0.0\t\t# push 0 onto stack", "\n");
emitStr(&stmts, "", "\t\tLTR\t\t\t# if x < 0 push 1, else push 0", "\n");
emitStr(&stmts, "", "\t\tIFZ __abs_pos\t\t# x >= 0, just return x", "\n");
emitStr(&stmts, "", "\t\tPUSH -3[0]\t\t# if x < 0, push it onto stack", "\n");
emitStr(&stmts, "", "\t\tCONSTR -1.0\t\t# push -1.0 onto stack", "\n");
emitStr(&stmts, "", "\t\tMULR\t\t\t# top of stack <-- x * (-1.0)", "\n");
emitStr(&stmts, "", "\t\tPOP -4[0]\t\t# place x in ret value location in stack", "\n");
emitStr(&stmts, "", "\t\tGOTO __abs_ret", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__abs_pos\tPUSH -3[0]\t\t# x is positive, push it onto stack", "\n");
emitStr(&stmts, "", "\t\tPOP -4[0]\t\t# place x in ret value location in stack", "\n");
emitStr(&stmts, "", "\t\tGOTO __abs_ret\t", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__abs_ret\tRET 0", "\n");
emitStr(&stmts, "", "# ASC implementation of char() function.", "\n");
emitStr(&stmts, "", "# From the expression x that shall be of integer-type, this function shall", "\n");
emitStr(&stmts, "", "# return a result of chartype that shall be the value whose", "\n");
emitStr(&stmts, "", "# oridnal number is equal to the value of the expression x, if such a character", "\n");
emitStr(&stmts, "", "# value exists.  It shall be an error if such a character value does not", "\n");
emitStr(&stmts, "", "# exist.", "\n");
emitStr(&stmts, "", "# It shall be true that chr(ord(ch)) = ch", "\n");
emitStr(&stmts, "", "__chr\t\t\tPUSH -3[0]\t# push ch onto stack", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 256\t# push max ascii val onto stack", "\n");
emitStr(&stmts, "", "\t\t\tGTI", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __chr_err\t# ch < 256 => not a char value", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]\t# return ch since we're using ascii", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__chr_err\t\t# PRINT ERROR MESSAGE", "\n");
emitStr(&stmts, "", "\t\t\tSTOP", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "###############################################################################", "\n");
emitStr(&stmts, "", "# __do_array_assignment : ", "\n");
emitStr(&stmts, "", "# Given two addresses which reference the base addresses of arrays and the", "\n");
emitStr(&stmts, "", "# size of the arrays (both arrays of the same size), __do_array_assignment", "\n");
emitStr(&stmts, "", "# copies the values from one array into the other. ", "\n");
emitStr(&stmts, "", "# Parameters:", "\n");
emitStr(&stmts, "", "#\t\t-5[0] : &x, the address of the array which is receiving values", "\n");
emitStr(&stmts, "", "#\t\t-4[0] : &y, the address of the array which is assigning values", "\n");
emitStr(&stmts, "", "#\t\t-3[0] : the size of the array", "\n");
emitStr(&stmts, "", "###############################################################################", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__do_array_assignment", "\n");
emitStr(&stmts, "", "\t\t\tADJUST 1\t\t# make num of chars to read a", "\n");
emitStr(&stmts, "", "\t\t\t\t\t\t# local variable", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "\t\t", "\n");
emitStr(&stmts, "", "\t\t\t# 1[0] will be the address to which we are trying", "\n");
emitStr(&stmts, "", "\t\t\t# to assign a new value", "\n");
emitStr(&stmts, "", "\t\t\tADJUST 1", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -5[0]", "\n");
emitStr(&stmts, "", "\t\t\tPOP 1[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# 2[0] will be the address which stores the value", "\n");
emitStr(&stmts, "", "\t\t\t# we want to assign to 1[0]", "\n");
emitStr(&stmts, "", "\t\t\tADJUST 1", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tPOP 2[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__do_loop\t", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]\t\t# top of stack <-- num of chars", "\n");
emitStr(&stmts, "", "\t\t\t\t\t\t# left to read", "\n");
emitStr(&stmts, "", "\t\t\tIFZ __do_done\t\t", "\n");
emitStr(&stmts, "", "\t\t\t# else, we have more values to assign  ", "\n");
emitStr(&stmts, "", "\t\t\t", "\n");
emitStr(&stmts, "", "\t\t\t# first push the lastest &x", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 1[0]", "\n");
emitStr(&stmts, "", "\t\t\t# push the lastest &y", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 2[0]", "\n");
emitStr(&stmts, "", "\t\t\t# replace &y with *y on the stack", "\n");
emitStr(&stmts, "", "\t\t\tPUSHI", "\n");
emitStr(&stmts, "", "\t\t\t# store the value *y at &x", "\n");
emitStr(&stmts, "", "\t\t\tPOPI", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# increment the addresses", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 1[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP 1[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 2[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP 2[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# decrement the counter", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "\t\t# do next iteration", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __do_loop", "\n");
emitStr(&stmts, "", "__do_done\t", "\n");
emitStr(&stmts, "", "\t\t\t!D", "\n");
emitStr(&stmts, "", "\t\t\t# kick local vars off the stack", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -3", "\n");
emitStr(&stmts, "", "\t\t\t# go away", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "################################################################################", "\n");
emitStr(&stmts, "", "# __do_str_eq_op():", "\n");
emitStr(&stmts, "", "# Given two strings (e.g., array of chars, strings literals are formatted/saved", "\n");
emitStr(&stmts, "", "# such that in these functions the two are indistinguishable), determines", "\n");
emitStr(&stmts, "", "# if they are exactly equal.", "\n");
emitStr(&stmts, "", "# Parameters", "\n");
emitStr(&stmts, "", "#\t\t-3[0] n : the size of strings to be compared", "\n");
emitStr(&stmts, "", "#\t\t-4[0] y : the RHS operand in the equality operation, an address", "\n");
emitStr(&stmts, "", "#\t\t-5[0] x : the LHS operand in the equality operation, an address", "\n");
emitStr(&stmts, "", "################################################################################", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__do_str_eq_op", "\n");
emitStr(&stmts, "", "\t\t# nothing to set up, let's get to it", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__do_str_eq_loop", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# push n onto the stack", "\n");
emitStr(&stmts, "", "\t\t\tIFZ __do_str_eq_true", "\n");
emitStr(&stmts, "", "\t\t\t# else, we have more comparasons to do", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tPUSHI", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -5[0]", "\n");
emitStr(&stmts, "", "\t\t\tPUSHI", "\n");
emitStr(&stmts, "", "\t\t\tEQI ", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __do_str_eq_false", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# increment &y", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# increment &x", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -5[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1", "\n");
emitStr(&stmts, "", "\t\t\tADDI ", "\n");
emitStr(&stmts, "", "\t\t\tPOP -5[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# decrement n", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP -3[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# do next iteration", "\n");
emitStr(&stmts, "", "\t\t\tgoto __do_str_eq_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__do_str_eq_true", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1", "\n");
emitStr(&stmts, "", "\t\t\tPOP -5[0]\t# save over last param as we", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# have no expectation that caller", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# allocated ret val memory", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __do_str_eq_ret", "\n");
emitStr(&stmts, "", "__do_str_eq_false", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 0", "\n");
emitStr(&stmts, "", "\t\t\tPOP -5[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__do_str_eq_ret\t\tRET 0 ", "\n");
emitStr(&stmts, "", "\t\t\t\t", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "################################################################################", "\n");
emitStr(&stmts, "", "# __do_str_lt_op()", "\n");
emitStr(&stmts, "", "# You know the drill.", "\n");
emitStr(&stmts, "", "# Parameters", "\n");
emitStr(&stmts, "", "#\t\t-3[0] n : the size of the strings to be compared", "\n");
emitStr(&stmts, "", "#\t\t-4[0] y : the RHS operand", "\n");
emitStr(&stmts, "", "#\t\t-5[0] x : the LHS operand", "\n");
emitStr(&stmts, "", "################################################################################", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__do_str_lt_op", "\n");
emitStr(&stmts, "", "\t\t\t# nothing to set up", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__do_str_lt_loop", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# push n onto the stack", "\n");
emitStr(&stmts, "", "\t\t\tIFZ __do_str_lt_false", "\n");
emitStr(&stmts, "", "\t\t\t", "\n");
emitStr(&stmts, "", "\t\t\t# push *y", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tPUSHI", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# push *x", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -5[0]", "\n");
emitStr(&stmts, "", "\t\t\tPUSHI", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# test *x < *y, if yes, we return true", "\n");
emitStr(&stmts, "", "\t\t\tLTI", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __do_str_lt_true", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# push *y", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tPUSHI", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# push *x", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -5[0]", "\n");
emitStr(&stmts, "", "\t\t\tPUSHI", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# test *x == *y, if yes we set up next iteration", "\n");
emitStr(&stmts, "", "\t\t\tEQI", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __do_str_lt_cont", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# else it must be that *x > *y, so we return false", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __do_str_lt_false", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__do_str_lt_cont", "\n");
emitStr(&stmts, "", "\t\t\t# set up next iteration", "\n");
emitStr(&stmts, "", "\t\t\t# increment &y", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]", "\n");
emitStr(&stmts, "", "\t\t", "\n");
emitStr(&stmts, "", "\t\t\t# increment &x", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -5[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP -5[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# decrement n", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tADDI ", "\n");
emitStr(&stmts, "", "\t\t\tPOP -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __do_str_lt_loop\t", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__do_str_lt_true", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1", "\n");
emitStr(&stmts, "", "\t\t\tPOP -5[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __do_str_lt_ret", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__do_str_lt_false", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 0", "\n");
emitStr(&stmts, "", "\t\t\tPOP -5[0]", "\n");
emitStr(&stmts, "", "__do_str_lt_ret", "\n");
emitStr(&stmts, "", "\t\t\tRET 0\t", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "################################################################################", "\n");
emitStr(&stmts, "", "# ASC implementation of the exponential funcion.", "\n");
emitStr(&stmts, "", "################################################################################", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# if x is an int, we simply raise e to the power x", "\n");
emitStr(&stmts, "", "__exp_int\t\tCONSTI 0\t\t# make room for return value\t", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t\t# push x onto the stack", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 2.7182818284\t# push ~e onto stack", "\n");
emitStr(&stmts, "", "\t\t\tCALL 0, __pow_real_int\t# raise e to the power x", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -2\t\t# kick params off the stack", "\n");
emitStr(&stmts, "", "\t\t", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__exp_real\t\tCONSTI 0", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tCALL 0, __is_bad_real", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -1", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __exp_err", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 10.0\t# if x > 10, call __exp_large_x to ", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# handle it", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tLTR\t\t# test x > 10.0", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __exp_large_x", "\n");
emitStr(&stmts, "", "\t\t\tADJUST 4\t# make room for k, k!, x^k, and sum", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# so far", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 35\t# we can only calculate up to 35", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# summands as 36! is not representable", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# in ASC (it is too large)", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0", "\n");
emitStr(&stmts, "", "\t\t\tPOP 3[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __exp_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__exp_loop\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 0", "\n");
emitStr(&stmts, "", "\t\t\tLTI", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __exp_done", "\n");
emitStr(&stmts, "", "\t\t\t", "\n");
emitStr(&stmts, "", "\t\t\t# calculate k!", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 0", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCALL 0, __factorial", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -1", "\n");
emitStr(&stmts, "", "\t\t\tPOP 1[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# calculate x^k", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 0", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tCALL 0, __pow_real_int", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -2", "\n");
emitStr(&stmts, "", "\t\t\tPOP 2[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# calculate next summand", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 2[0]", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 1[0]", "\n");
emitStr(&stmts, "", "\t\t\tDIVR", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 3[0]", "\n");
emitStr(&stmts, "", "\t\t\tADDR", "\n");
emitStr(&stmts, "", "\t\t\tPOP 3[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __exp_loop", "\n");
emitStr(&stmts, "", "\t\t\t", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__exp_err\t\t# print error message", "\n");
emitStr(&stmts, "", "\t\t\tSTOP", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__exp_done\t\tPUSH 3[0]", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -4", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "# If x is particularily large we need a special method to compute its value", "\n");
emitStr(&stmts, "", "# as the method above converges slowly and returns bad resuls for even modest", "\n");
emitStr(&stmts, "", "# values of x (e.g., > 50).", "\n");
emitStr(&stmts, "", "__exp_large_x\t\tADJUST 4\t\t# make room for n, x-n, e^n, and", "\n");
emitStr(&stmts, "", "\t\t\t\t\t\t# e^(x-n) \t", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t\t# push x onto the stack", "\n");
emitStr(&stmts, "", "\t\t\tRTOI\t\t\t# truncate it by converting it", "\n");
emitStr(&stmts, "", "\t\t\t\t\t\t# to an integer", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]\t\t# store n back into stack", "\n");
emitStr(&stmts, "", "\t\t\t# calculate x-n", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t\t# push n, x onto the stack", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tITOR", "\n");
emitStr(&stmts, "", "\t\t\tSUBR\t\t\t# top of stack <-- x-n", "\n");
emitStr(&stmts, "", "\t\t\tPOP 1[0]\t\t# save this value back in stack", "\n");
emitStr(&stmts, "", "\t\t\t# now we get e^n", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 0\t\t# make room for ret value", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCALL 0, __exp_int\t", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -1", "\n");
emitStr(&stmts, "", "\t\t\tPOP 2[0]", "\n");
emitStr(&stmts, "", "\t\t\t\t\t", "\n");
emitStr(&stmts, "", "\t", "\n");
emitStr(&stmts, "", "\t\t\t# now we get e^(x-n)", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 0", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 1[0]", "\n");
emitStr(&stmts, "", "\t\t\tCALL 0, __exp_real", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -1", "\n");
emitStr(&stmts, "", "\t\t\tPOP 3[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# calculate final value", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 3[0]", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 2[0]", "\n");
emitStr(&stmts, "", "\t\t\tMULR", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -4", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "###############################################################################", "\n");
emitStr(&stmts, "", "# factorial(n) - returns n! (useful in calculating values of trig functions)", "\n");
emitStr(&stmts, "", "# --> returns the n! as a real such that we can express larger factorial values", "\n");
emitStr(&stmts, "", "###############################################################################", "\n");
emitStr(&stmts, "", "__factorial\t\tADJUST 1\t# make room for local var tmp", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# push n onto stack", "\n");
emitStr(&stmts, "", "\t\t\tIFZ __factorial_zero #handle special case n = 0", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# push n onto stack", "\n");
emitStr(&stmts, "", "\t\t\tITOR\t\t# make n a real", "\n");
emitStr(&stmts, "", "\t\t\tPOP -3[0]\t# save n as a real", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# put n onto stack", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]\t# tmp <-- n", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __factorial_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__factorial_zero\tCONSTR 1.0", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __factorial_done", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__factorial_loop\tPUSH -3[0]\t# push n onto stack", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR -1.0\t# push -1 onto stack", "\n");
emitStr(&stmts, "", "\t\t\tADDR\t\t# top of stack <-- n - 1", "\n");
emitStr(&stmts, "", "\t\t\tPOP -3[0]\t# n <-- n - 1", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# push n-1 onto stack", "\n");
emitStr(&stmts, "", "\t\t\tIFZ __factorial_done", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# push n-1 onto stack", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]\t# push tmp onto stack", "\n");
emitStr(&stmts, "", "\t\t\tMULR\t\t# top of stack <-- tmp * (n - 1)", "\n");
emitStr(&stmts, "", "\t\t\t# TODO: add test for > maxint, set run-time error ", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]\t# tmp <-- tmp * (n - 1)", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __factorial_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__factorial_done\tPUSH 0[0]\t# push tmp onto stack", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]\t# save tmp as ret value", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -1\t# kick local vars off stack", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __factorial_ret", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__factorial_ret\t\tRET 0", "\n");
emitStr(&stmts, "", "# Returns true if the given real is nan, +inf or -inf.", "\n");
emitStr(&stmts, "", "# Returns otherwise.", "\n");
emitStr(&stmts, "", "__is_bad_real\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\tRTOI", "\n");
emitStr(&stmts, "", "\t\tCONSTI 2146435072\t# push nan onto stack", "\n");
emitStr(&stmts, "", "\t\tRTOI", "\n");
emitStr(&stmts, "", "\t\tEQI", "\n");
emitStr(&stmts, "", "\t\tIFNZ __is_bad_real_true", "\n");
emitStr(&stmts, "", "\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\tRTOI", "\n");
emitStr(&stmts, "", "\t\tCONSTI 2139095040\t# push +inf onto stack", "\n");
emitStr(&stmts, "", "\t\tRTOI", "\n");
emitStr(&stmts, "", "\t\tEQI", "\n");
emitStr(&stmts, "", "\t\tIFNZ __is_bad_real_true", "\n");
emitStr(&stmts, "", "\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\tRTOI", "\n");
emitStr(&stmts, "", "\t\tCONSTI -8388608\t\t# push -inf onto stack", "\n");
emitStr(&stmts, "", "\t\tRTOI", "\n");
emitStr(&stmts, "", "\t\tEQI", "\n");
emitStr(&stmts, "", "\t\tIFNZ __is_bad_real_true", "\n");
emitStr(&stmts, "", "\t\tCONSTI 0", "\n");
emitStr(&stmts, "", "\t\tPOP -4[0]", "\n");
emitStr(&stmts, "", "\t\tGOTO __is_bad_real_ret", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__is_bad_real_true\tCONSTI 1", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __is_bad_real_ret", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__is_bad_real_ret\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__ln_int\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tITOR", "\n");
emitStr(&stmts, "", "\t\t\tPOP -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __ln_real", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__ln_real\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0", "\n");
emitStr(&stmts, "", "\t\t\tEQR", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __ln_err", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0", "\n");
emitStr(&stmts, "", "\t\t\tLTR", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __ln_err", "\n");
emitStr(&stmts, "", "\t\t\t# x has been validated, let's start calculating", "\n");
emitStr(&stmts, "", "\t\t\t# ln(x)'s Taylor series", "\n");
emitStr(&stmts, "", "\t\t\tADJUST 7\t# make room for local vars", "\n");
emitStr(&stmts, "", "\t\t\t# 0[0] = k -> summation index", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 7", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "\t\t\t# 0[1] = (-1)^(k+1) ", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0", "\n");
emitStr(&stmts, "", "\t\t\tPOP 1[0]", "\n");
emitStr(&stmts, "", "\t\t\t# 2[0] = (x - 1)^k", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0", "\n");
emitStr(&stmts, "", "\t\t\tPOP 2[0]", "\n");
emitStr(&stmts, "", "\t\t\t# 3[0] = sum so far", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0", "\n");
emitStr(&stmts, "", "\t\t\tPOP 3[0]", "\n");
emitStr(&stmts, "", "\t\t\t# test if x < 1", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 1.0", "\n");
emitStr(&stmts, "", "\t\t\tLTR", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __ln_increase_arg", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __ln_reduce_arg", "\n");
emitStr(&stmts, "", "\t\t\t# offsets 4,5,6 will store m, exp(m) and x*exp(-m) ", "\n");
emitStr(&stmts, "", "\t\t\t# where m in the smallest integer such that", "\n");
emitStr(&stmts, "", "\t\t\t# x < exp(m)  ", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# x < 1, so we have to bring it back into the range", "\n");
emitStr(&stmts, "", "\t\t\t# that which we can handle", "\n");
emitStr(&stmts, "", "__ln_increase_arg\tCONSTI 0", "\n");
emitStr(&stmts, "", "\t\t\tPOP 4[0]\t# our initial guess for -m is 0", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __ln_increase_aarg_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__ln_increase_aarg_loop #!D ", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 0\t# make room for ret value", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 4[0]\t# push -m onto stack", "\n");
emitStr(&stmts, "", "\t\t\tCALL 0, __exp_int", "\n");
emitStr(&stmts, "", "\t\t\t#!D", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -1\t", "\n");
emitStr(&stmts, "", "\t\t\tPOP 5[0]\t# save exp(-m) into the stack", "\n");
emitStr(&stmts, "", "\t\t\t#!D", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 5[0]\t# push exp(-m)", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# push x onto stack", "\n");
emitStr(&stmts, "", "\t\t\t#!D", "\n");
emitStr(&stmts, "", "\t\t\tLTR\t\t# test x > exp(-m)", "\n");
emitStr(&stmts, "", "\t\t\t#!D", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __ln_loop_prep", "\n");
emitStr(&stmts, "", "\t\t\t# else decrement m and try again", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 4[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP 4[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __ln_increase_aarg_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# x > 2, so we have to bring it back into the range", "\n");
emitStr(&stmts, "", "\t\t\t# that we can handle", "\n");
emitStr(&stmts, "", "__ln_reduce_arg\t\tCONSTI 0", "\n");
emitStr(&stmts, "", "\t\t\tPOP 4[0]\t# our initial guess for m is 0", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __ln_reduce_arg_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__ln_reduce_arg_loop\tCONSTI 0\t# make room for ret value", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 4[0]\t# push m onto stack", "\n");
emitStr(&stmts, "", "\t\t\tCALL 0, __exp_int\t# calculate exp(m)", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -1\t# top of stack <-- exp(m)", "\n");
emitStr(&stmts, "", "\t\t\tPOP 5[0]\t# save exp(m) into stack", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 5[0]\t# push exp(m) onto stack", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# push x onto stack", "\n");
emitStr(&stmts, "", "\t\t\tGTR\t\t# test x < exp(m)", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __ln_loop_prep", "\n");
emitStr(&stmts, "", "\t\t\t# else increment m and try again", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 4[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP 4[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __ln_reduce_arg_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__ln_loop_prep\t\t#!D", "\n");
emitStr(&stmts, "", "\t\t\t# correct m value found, we calculate x*exp(-m)", "\n");
emitStr(&stmts, "", "\t\t\t# which the value we use use as y in the expression", "\n");
emitStr(&stmts, "", "\t\t\t# ln(y) which is calculated by Taylor expansion", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 0\t\t\t", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 4[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tMULI", "\n");
emitStr(&stmts, "", "\t\t\tCALL 0, __exp_int", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -1", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tMULR", "\n");
emitStr(&stmts, "", "\t\t\tPOP 6[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __ln_loop", "\n");
emitStr(&stmts, "", "\t\t\t", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__ln_loop\t\tPUSH 0[0]\t# push k onto stack and decrement", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1\t", "\n");
emitStr(&stmts, "", "\t\t\tADDI\t\t# top of stack <- k-1", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]\t# save k-1 as new k value", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]\t# push k onto stack", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 0\t", "\n");
emitStr(&stmts, "", "\t\t\tEQI\t\t# test k == 0", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __ln_done", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# first calculate (-1)^k+1", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0\t# make room for return value", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1\t# top of stack <-- k+1\t", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1 ", "\n");
emitStr(&stmts, "", "\t\t\tCALL 0, __pow_int_int", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -2\t# kick params off stack", "\n");
emitStr(&stmts, "", "\t\t\tPOP 1[0]\t# save (-1)^(k+1) back into stack", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# next calculate (x-1)^k", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0\t# make room for ret", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]\t# push k", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 6[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR -1.0", "\n");
emitStr(&stmts, "", "\t\t\tADDR\t\t# top of stack <-- x-1", "\n");
emitStr(&stmts, "", "\t\t\tCALL 0, __pow_real_int", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -2\t# kick params off stack", "\n");
emitStr(&stmts, "", "\t\t\tPOP 2[0]\t# save value back into stack", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# ready to calculate next summand", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 1[0]\t# push (-1)^(k+1)", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]\t# push k onto the stack", "\n");
emitStr(&stmts, "", "\t\t\tITOR", "\n");
emitStr(&stmts, "", "\t\t\tDIVR\t\t# top of stack <-- ((-1)^(k+1)) / k", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 2[0]\t# push (x-1)^k onto the stack", "\n");
emitStr(&stmts, "", "\t\t\tMULR\t\t# top of stack <-- kth summand", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 3[0]\t# push sum so far onto stack", "\n");
emitStr(&stmts, "", "\t\t\tADDR", "\n");
emitStr(&stmts, "", "\t\t\tPOP 3[0]\t# save kth summand + sum so far", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __ln_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__ln_err\t\t#TODO print error message", "\n");
emitStr(&stmts, "", "\t\t\tSTOP", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__ln_done\t\tPUSH 3[0]", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 4[0]", "\n");
emitStr(&stmts, "", "\t\t\tITOR", "\n");
emitStr(&stmts, "", "\t\t\tADDR", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]\t# save sum as return value", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -7\t# kick local vars off stack", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "# ASC code for the predefined function odd(x)", "\n");
emitStr(&stmts, "", "# Definition (from standard):", "\n");
emitStr(&stmts, "", "# From the expression x that shall be of integer-type, this function shall be", "\n");
emitStr(&stmts, "", "# equivalent to the expression", "\n");
emitStr(&stmts, "", "# \t(abs(x) mod 2 = 1) (note abs(s) not necessary, x = -x mod 2 for all x)", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__odd:\t\tPUSH -3[0]\t\t# push x onto the top of the stack", "\n");
emitStr(&stmts, "", "\t\tCONSTI 2\t\t# push 2 onto the top of the stack", "\n");
emitStr(&stmts, "", "\t\tMOD\t\t\t# top of stack <-- x mod 2", "\n");
emitStr(&stmts, "", "\t\tPOP -4[0]\t\t# place result in the section of the ", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# stack reservered for return values", "\n");
emitStr(&stmts, "", "\t\tRET 0\t\t\t# pop the 0th display register frame", "\n");
emitStr(&stmts, "", "# ASC implementation of the ord() function.", "\n");
emitStr(&stmts, "", "# From the expression x that shall be of an ordinal-type, this function shall", "\n");
emitStr(&stmts, "", "# return a result of integer-type that shall be the ordinal number of the value", "\n");
emitStr(&stmts, "", "# of the expression x.", "\n");
emitStr(&stmts, "", "#", "\n");
emitStr(&stmts, "", "# For us this is really easy: all ordinal types are represented as ints,", "\n");
emitStr(&stmts, "", "# so we literally just return the value we were given.  Fantastic.", "\n");
emitStr(&stmts, "", "__ord\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\tPOP -4[0]", "\n");
emitStr(&stmts, "", "\t\tRET 0", "\n");
emitStr(&stmts, "", "#", "\n");
emitStr(&stmts, "", "# Not a pre-defined function, but a helpful one with calculations used ", "\n");
emitStr(&stmts, "", "# in other pre-defined functions.", "\n");
emitStr(&stmts, "", "# Takes as args x, n (n always int) and return x^n as a real", "\n");
emitStr(&stmts, "", "#", "\n");
emitStr(&stmts, "", "__pow_int_int\t\tPUSH -3[0]\t# push x onto stack", "\n");
emitStr(&stmts, "", "\t\t\tITOR\t\t# convert it to a real", "\n");
emitStr(&stmts, "", "\t\t\tPOP -3[0]\t# place it in param 1 location in stack", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __pow_real_int", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__pow_real_int\t\tPUSH -4[0]\t# push n onto stack", "\n");
emitStr(&stmts, "", "\t\t\tIFZ __pow_zeroexp\t# n = 0, return 1", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# push x onto stack", "\n");
emitStr(&stmts, "", "\t\t\tIFZ __pow_zerobase", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -4[0]\t# push n onto stack", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 0\t# test n < 0", "\n");
emitStr(&stmts, "", "\t\t\tLTI", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __pow_neg\t# handle special case x < 0", "\n");
emitStr(&stmts, "", "\t\t\t# else, nonzero base and exp and we have work to do", "\n");
emitStr(&stmts, "", "\t\t\tADJUST 1\t# make room on stack for tmp", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# push x onto stack", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]\t# store tmp <-- x, tmp will be used", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# as rolling value as we continually", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# multiply x by itself", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __pow_real_int_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__pow_neg\t\tADJUST 1", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 1.0", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tDIVR", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "\t\t\t# now we make n positive for easier looping", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tMULI", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __pow_neg_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__pow_neg_loop\t\tPUSH -4[0]\t# n > 0, so decrement it", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]\t# n <-- n - 1", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -4[0]\t#push n onto stack", "\n");
emitStr(&stmts, "", "\t\t\tIFZ __pow_neg_done", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]\t# push tmp onto stack", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# push onto stack", "\n");
emitStr(&stmts, "", "\t\t\tDIVR\t\t# top of stack <-- tmp  x", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]\t# store result as new tmp", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __pow_neg_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__pow_neg_done\t\tPUSH 0[0]\t# put tmp on top of stack", "\n");
emitStr(&stmts, "", "\t\t\tPOP -5[0]\t# save tmp as ret value", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -1\t# kick local vars off stack", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __pow_ret", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__pow_real_int_loop\tPUSH -4[0]\t# n > 0, so decrement it", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]\t# n <-- n - 1", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -4[0]\t#push n onto stack", "\n");
emitStr(&stmts, "", "\t\t\tIFZ __pow_real_int_done", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]\t# push tmp onto stack", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# push onto stack", "\n");
emitStr(&stmts, "", "\t\t\tMULR\t\t# top of stack <-- tmp * x", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]\t# store result as new tmp", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __pow_real_int_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__pow_real_int_done\tPUSH 0[0]\t# put tmp on top of stack", "\n");
emitStr(&stmts, "", "\t\t\tPOP -5[0]\t# save tmp as ret value", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -1\t# kick local vars off stack", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __pow_ret", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__pow_zeroexp\t\tCONSTR 1.0\t# push 1.0 onto stack", "\n");
emitStr(&stmts, "", "\t\t\tPOP -5[0]\t# place 1.0 in ret val location in stack", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __pow_ret", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__pow_zerobase\t\tCONSTR 0.0\t# push 0.0 onto stack", "\n");
emitStr(&stmts, "", "\t\t\tPOP -5[0]\t# place 0.0 in ret val location in stack", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __pow_ret", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__pow_ret\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "# ASC implementation of the function pred()", "\n");
emitStr(&stmts, "", "# From the expression x that shall be of an ordinal-type, this function shall", "\n");
emitStr(&stmts, "", "# return a result that shall be of the same type as that of the expression.", "\n");
emitStr(&stmts, "", "# The function shall yield a value whose ordinal number is one less that that", "\n");
emitStr(&stmts, "", "# of the expression x, if such a value exists.  It shall be an error if such a", "\n");
emitStr(&stmts, "", "# a value does not exist.", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "# __pred for integers #########################################################", "\n");
emitStr(&stmts, "", "__pred_int\t\tPUSH -3[0]\t# push x onto the stack", "\n");
emitStr(&stmts, "", "\t\t\t# TODO: test if == minint", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1\t# push -1 onto stack", "\n");
emitStr(&stmts, "", "\t\t\tADDI\t\t# x <-- x-1", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]\t# save x-1 as ret value", "\n");
emitStr(&stmts, "", "\t\t\tRET 0\t", "\n");
emitStr(&stmts, "", "__pred_error\t\t# value passed == minint, no predecessor", "\n");
emitStr(&stmts, "", "\t\t\tSTOP", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "# __pred for booleans #########################################################", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__pred_bool\t\tPUSH -3[0]\t# push x onto the stack", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1\t# push 1 onto the stack", "\n");
emitStr(&stmts, "", "\t\t\tEQI\t\t# if x != 1, has no predecessor", "\n");
emitStr(&stmts, "", "\t\t\tIFZ __pred_bool_err", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 0\t# else, save 0 as ret value", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__pred_bool_err\t\t# no predecessor", "\n");
emitStr(&stmts, "", "\t\t\tSTOP", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "# __pred for scalar enumerations ##############################################", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__pred_scalar\t\tPUSH -3[0]\t# test if x == 0", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 0", "\n");
emitStr(&stmts, "", "\t\t\tEQI", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __pred_scalar_err\t# x == 0, error", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# if not, then decrement and return", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__pred_scalar_err\t# no predecessor", "\n");
emitStr(&stmts, "", "\t\t\tSTOP", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "# __pred for chars ############################################################", "\n");
emitStr(&stmts, "", "__pred_char\t\tPUSH -3[0]\t# test if x == 0", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 0", "\n");
emitStr(&stmts, "", "\t\t\tEQI", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __pred_char_err\t# x == 0, error", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# if not, then decrement and return", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__pred_char_err\t# no predecessor", "\n");
emitStr(&stmts, "", "\t\t\tSTOP", "\n");
emitStr(&stmts, "", "\t\t\t", "\n");
emitStr(&stmts, "", "# ASC implementation of read()", "\n");
emitStr(&stmts, "", "# Calling convention:", "\n");
emitStr(&stmts, "", "#\t- for ints and real, just push param as usual (i.e., param is the ", "\n");
emitStr(&stmts, "", "#\t  address where the value read in is to be placed)", "\n");
emitStr(&stmts, "", "#\t- for chars/strs, first param is the number of chars to read (e.g.,", "\n");
emitStr(&stmts, "", "#\t  if we want to read(s) where s : array[1..10] of char, then the first", "\n");
emitStr(&stmts, "", "#\t  param should be 10 and read() will assume -13[0] is the address", "\n");
emitStr(&stmts, "", "#\t  into which to return the first char read (e.g., s[1])", "\n");
emitStr(&stmts, "", "# NOTE: check err flag after reading from input, if it does not get the type", "\n");
emitStr(&stmts, "", "# it is expecting then it is a run time error and the program will halt.", "\n");
emitStr(&stmts, "", "__read_str\t\tADJUST 1\t# make # of chars to read a local var", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __read_str_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__read_str_loop\t\tPUSH 0[0]\t# top of stack <-- # char left to read", "\n");
emitStr(&stmts, "", "\t\t\tIFZ __read_str_done", "\n");
emitStr(&stmts, "", "\t\t\t# else we have more chars to read", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tMULI", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -3", "\n");
emitStr(&stmts, "", "\t\t\tADDI \t\t# top of stack <- offset to next param", "\n");
emitStr(&stmts, "", "\t\t\tREADC\t\t# get char from stdin", "\n");
emitStr(&stmts, "", "\t\t\tIFERR __read_str_err ", "\n");
emitStr(&stmts, "", "\t\t\tPOPI 0\t\t# store read char at &x", "\n");
emitStr(&stmts, "", "\t\t\t# decrement # of chars left to print", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __read_str_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__read_str_done\t\tADJUST -1", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__read_str_err\t\tCONSTI 90\t# TODO: print real error message", "\n");
emitStr(&stmts, "", "\t\t\tWRITEC", "\n");
emitStr(&stmts, "", "\t\t\tSTOP", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__read_int\t\tPUSH -3[0]\t# push &x onto stack", "\n");
emitStr(&stmts, "", "\t\t\tREADI\t\t# read int from stdin", "\n");
emitStr(&stmts, "", "\t\t\tIFERR __read_int_err", "\n");
emitStr(&stmts, "", "\t\t\tPOPI\t\t# pop value read from stdin to", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# address specified by param", "\n");
emitStr(&stmts, "", "\t\t\tRET 0\t\t", "\n");
emitStr(&stmts, "", "\t\t\t", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__read_int_err\t\t# TODO: produce error message", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 90", "\n");
emitStr(&stmts, "", "\t\t\tWRITEI", "\n");
emitStr(&stmts, "", "\t\t\tSTOP", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__read_real\t\tPUSH -3[0]\t# push &x onto stack", "\n");
emitStr(&stmts, "", "\t\t\tREADR\t\t# read real from stdin", "\n");
emitStr(&stmts, "", "\t\t\tIFERR __read_real_err", "\n");
emitStr(&stmts, "", "\t\t\tPOPI\t\t# pop value read from stdin to addr", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# specified by param", "\n");
emitStr(&stmts, "", "\t\t\tRET 0\t\t", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__read_real_err\t\tSTOP \t\t# TODO print error", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "# ASC implementation of readln()", "\n");
emitStr(&stmts, "", "# Calling convention:", "\n");
emitStr(&stmts, "", "#\t- for ints and real, just push param as usual (i.e., param is the ", "\n");
emitStr(&stmts, "", "#\t  address where the value read in is to be placed)", "\n");
emitStr(&stmts, "", "#\t- for chars/strs, first param is the number of chars to read (e.g.,", "\n");
emitStr(&stmts, "", "#\t  if we want to readln(s) where s : array[1..10] of char, then the first", "\n");
emitStr(&stmts, "", "#\t  param should be 10 and readln() will assume -13[0] is the address", "\n");
emitStr(&stmts, "", "#\t  into which to return the first char read (e.g., s[1])", "\n");
emitStr(&stmts, "", "# NOTE: check err flag after reading from input, if it does not get the type", "\n");
emitStr(&stmts, "", "# it is expecting then it is a run time error and the program will halt.", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__readln_str\t\tADJUST 1\t# make # of chars to read a local var", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __readln_str_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__readln_str_loop\tPUSH 0[0]\t# top of stack <-- # char left to read", "\n");
emitStr(&stmts, "", "\t\t\tIFZ __readln_str_done", "\n");
emitStr(&stmts, "", "\t\t\t# else we have more chars to read", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tMULI", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -3", "\n");
emitStr(&stmts, "", "\t\t\tADDI \t\t# top of stack <- offset to next param", "\n");
emitStr(&stmts, "", "\t\t\tPUSHI 0\t\t# push address param onto the stack", "\n");
emitStr(&stmts, "", "\t\t\tREADC\t\t# get char from stdin", "\n");
emitStr(&stmts, "", "\t\t\tIFERR __readln_str_err ", "\n");
emitStr(&stmts, "", "\t\t\tDUP\t\t# push extra copy of read in char onto", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# stack as we need to test it for", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# equality with newline", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 10\t# ascii val of newline char", "\n");
emitStr(&stmts, "", "\t\t\tEQI\t\t# see read in char == newline", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __readln_str_nl_done", "\n");
emitStr(&stmts, "", "\t\t\tPOPI \t\t# store read char at &x", "\n");
emitStr(&stmts, "", "\t\t\t# decrement # of chars left to print", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __readln_str_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__readln_str_nl_done\t# stopped reading because we caugh a newline, so", "\n");
emitStr(&stmts, "", "\t\t\t# we have two extra values on stack we need to kick off", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -2", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __readln_str_done", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__readln_str_done\tADJUST -1", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 10", "\n");
emitStr(&stmts, "", "\t\t\tWRITEC", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__readln_str_err\tCONSTI 90\t# TODO: print real error message", "\n");
emitStr(&stmts, "", "\t\t\tWRITEC", "\n");
emitStr(&stmts, "", "\t\t\tSTOP", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__readln_int\t\tPUSH -3[0]\t# push &x onto stack", "\n");
emitStr(&stmts, "", "\t\t\tREADI\t\t# read int from stdin", "\n");
emitStr(&stmts, "", "\t\t\tIFERR __readln_int_err", "\n");
emitStr(&stmts, "", "\t\t\tPOPI\t\t# pop value read from stdin to", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# address specified by param", "\n");
emitStr(&stmts, "", "\t\t\tREADC\t\t# consume newline", "\n");
emitStr(&stmts, "", "\t\t\tWRITEC", "\n");
emitStr(&stmts, "", "\t\t\tRET 0\t\t", "\n");
emitStr(&stmts, "", "\t\t\t", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__readln_int_err\t# TODO: produce error message", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 90", "\n");
emitStr(&stmts, "", "\t\t\tWRITEI", "\n");
emitStr(&stmts, "", "\t\t\tSTOP", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__readln_real\t\tPUSH -2[0]\t# push &x onto stack", "\n");
emitStr(&stmts, "", "\t\t\tREADR\t\t# read real from stdin", "\n");
emitStr(&stmts, "", "\t\t\tIFERR __readln_real_err", "\n");
emitStr(&stmts, "", "\t\t\tPOPI\t\t# pop value read from stdin to addr", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# specified by param", "\n");
emitStr(&stmts, "", "\t\t\tREADC\t\t# consume newline", "\n");
emitStr(&stmts, "", "\t\t\tWRITEC", "\n");
emitStr(&stmts, "", "\t\t\tRET 0\t\t", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__readln_real_err\tSTOP \t\t# TODO print error", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "# ASC implementation of round()", "\n");
emitStr(&stmts, "", "# From the expression x that shall be of real-type, this function shall return", "\n");
emitStr(&stmts, "", "# a result of integertype.  If x is positive or zero, round(x) shall be ", "\n");
emitStr(&stmts, "", "# equivalent to trunc(x + 0.5) ; otherwise, round(x) shall be equivalent to", "\n");
emitStr(&stmts, "", "# trunc(x - 0.5).  It shall be an error if such a value does not exist.  It", "\n");
emitStr(&stmts, "", "# shall be an error if such a value does not exist.", "\n");
emitStr(&stmts, "", "# TODO: check for error in case of x = inf or x = nan", "\n");
emitStr(&stmts, "", "__round\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0", "\n");
emitStr(&stmts, "", "\t\t\tGTR", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __round_pos", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0", "\n");
emitStr(&stmts, "", "\t\t\tEQR", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __round_zero", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __round_neg", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__round_pos\t\tCONSTI 0\t# make room for ret on stack", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.5\t", "\n");
emitStr(&stmts, "", "\t\t\tADDR\t\t# x <-- x + 0.5", "\n");
emitStr(&stmts, "", "\t\t\tCALL 0, __trunc", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -1\t# kick param off the stack", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]\t# make ret val from trunc() our ret val", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __round_ret", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__round_zero\t\tCONSTI 0\t# x == 0.0, return int 0", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __round_ret", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__round_neg\t\tCONSTI 0\t# make room for ret val on stack", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR -0.5", "\n");
emitStr(&stmts, "", "\t\t\tADDR", "\n");
emitStr(&stmts, "", "\t\t\tCALL 0, __trunc", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -1\t# kick param off the stack", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]\t# make ret val from trunc() our ret val", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __round_ret", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__round_ret\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "###############################################################################", "\n");
emitStr(&stmts, "", "# sin(x) - returns the value of the sine of x where x is in radians.", "\n");
emitStr(&stmts, "", "# We're going to approximate the value of sine by calculating \"enough\" terms", "\n");
emitStr(&stmts, "", "# of its Taylor series.", "\n");
emitStr(&stmts, "", "###############################################################################", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__sin_int\t\tPUSH -3[0]\t# push x onto stack", "\n");
emitStr(&stmts, "", "\t\t\tITOR\t\t# conver to real", "\n");
emitStr(&stmts, "", "\t\t\tPOP -3[0]\t# push into param slot", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __sin_real\t# \"call\" real valued version of sin()", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__sin_real\t\tCONSTI 0", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tCALL 0, __is_bad_real", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -1", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __exp_err\t\t", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\tADJUST 1\t# make room for k = summation index", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# in the taylor series for sine", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 6\t# We are going to sum the first 6", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# series", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\tADJUST 1\t# make room for (-1)^k", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0\t", "\n");
emitStr(&stmts, "", "\t\t\tPOP 1[0]\t# set (-1)^k = 0 for now", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\tADJUST 1\t# make room for (2k + 1)!", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0", "\n");
emitStr(&stmts, "", "\t\t\tPOP 2[0]\t# set it to zero for now", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\tADJUST 1\t# make room for x^(2k+1) and set to 0", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0", "\n");
emitStr(&stmts, "", "\t\t\tPOP 3[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# make room for value of sum so far, set to 0", "\n");
emitStr(&stmts, "", "\t\t\tADJUST 1\t", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0", "\n");
emitStr(&stmts, "", "\t\t\tPOP 4[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __sin_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__sin_loop\t\tPUSH 0[0]\t# push k onto stack", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1\t# push -1 onto stack", "\n");
emitStr(&stmts, "", "\t\t\tADDI\t\t# k <- k-1", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]\t# save new value of k", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]\t# push k onto stack", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 0\t# push 0 onto stack", "\n");
emitStr(&stmts, "", "\t\t\tLTI", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __sin_done\t# k < 0 => we are done", "\n");
emitStr(&stmts, "", "\t\t\t# else, we calculate the next summand", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t#first calculate (-1)^k, make call to __pow_int_int", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0\t# make room for ret value", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]\t# push k as second param", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1\t# push -1 as first param", "\n");
emitStr(&stmts, "", "\t\t\tCALL 0, __pow_int_int", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -2\t# kick params off the stack", "\n");
emitStr(&stmts, "", "\t\t\tPOP 1[0]\t# save (-1)^k back into local vars", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t#next calculate (2k + 1)!", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0\t# make room for ret value", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]\t# push k onto stack", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 2\t# push 2 onto stack", "\n");
emitStr(&stmts, "", "\t\t\tMULI\t\t# top of stack <-- 2*k", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1\t# push 1 onto stack", "\n");
emitStr(&stmts, "", "\t\t\tADDI\t\t# top of stack <-- 2*k + 1", "\n");
emitStr(&stmts, "", "\t\t\tCALL 0, __factorial", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -1\t# kick param off stack", "\n");
emitStr(&stmts, "", "\t\t\tPOP 2[0]\t# save (2k+1)! back into local vars", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# next we calculate x^(2k+1)", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0\t# make room for ret value", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]\t# push k onto stack", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 2\t# push 2 onto stack", "\n");
emitStr(&stmts, "", "\t\t\tMULI\t\t# top of stack <-- 2*k", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1\t# push 1 onto stack", "\n");
emitStr(&stmts, "", "\t\t\tADDI\t\t# top of stack <-- 2k+1", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# push x onto stack", "\n");
emitStr(&stmts, "", "\t\t\tCALL 0, __pow_real_int", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -2\t# kick local vars off the stack", "\n");
emitStr(&stmts, "", "\t\t\tPOP 3[0]\t# save val back into local vars", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# we're finally ready to calculate the summand", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 1[0]\t# push (-1)^k", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 2[0]\t# push (2k + 1)!", "\n");
emitStr(&stmts, "", "\t\t\tDIVR\t\t# top of stack <-- (-1)^k/(2k+1)!", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 3[0]\t# push x^(2k+1)", "\n");
emitStr(&stmts, "", "\t\t\tMULR\t\t# top of stack <-- summand", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 4[0]\t# push sum so far onto stack", "\n");
emitStr(&stmts, "", "\t\t\tADDR\t\t# add summand to sum so far", "\n");
emitStr(&stmts, "", "\t\t\tPOP 4[0]\t# save sum so far", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __sin_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__sin_done\t\tPUSH 4[0]\t# push sum so far onto stack", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]\t# save it as ret value", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -5\t#kick local vars off the stack", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __sin_ret", "\n");
emitStr(&stmts, "", "__sin_ret\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "# ASC implementation of the function sqr.", "\n");
emitStr(&stmts, "", "# square of x", "\n");
emitStr(&stmts, "", "# It shall be an error if such a value does not exist.", "\n");
emitStr(&stmts, "", "# TODO: insure all errors are caught (NOT THE CASE RIGHT NOW)", "\n");
emitStr(&stmts, "", "__sqr_int\tPUSH -3[0]\t\t# push x onto stack", "\n");
emitStr(&stmts, "", "\t\tPUSH -3[0]\t\t# push x onto stack (again)", "\n");
emitStr(&stmts, "", "\t\tMULI\t\t\t# top of stack <-- x * x", "\n");
emitStr(&stmts, "", "\t\tGOTO __sqr_ret", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__sqr_real\tCONSTI 0", "\n");
emitStr(&stmts, "", "\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\tCALL 0, __is_bad_real", "\n");
emitStr(&stmts, "", "\t\tIFNZ __sqr_err", "\n");
emitStr(&stmts, "", "\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\tMULR", "\n");
emitStr(&stmts, "", "\t\tGOTO __sqr_ret", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__sqr_err\t# print error message", "\n");
emitStr(&stmts, "", "\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__sqr_ret\tPOP -4[0]", "\n");
emitStr(&stmts, "", "\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "# ASC implementation of the sqrt() function.", "\n");
emitStr(&stmts, "", "# non-negative square root of x, if x is not negative", "\n");
emitStr(&stmts, "", "# It shall be an error if x is negative.", "\n");
emitStr(&stmts, "", "# The standard specifies that sqrt() accepts both ints and reals, but always returns real.", "\n");
emitStr(&stmts, "", "# The strategy employed follows from en.wikipedia.org/wiki/Square_root", "\n");
emitStr(&stmts, "", "# To find sqrt(x), do:", "\n");
emitStr(&stmts, "", "#\t-> start with arbitrary a, set a <-- (a + x/a)", "\n");
emitStr(&stmts, "", "#\t-> keep iterating the value of a as give above, apparently you'll eventually get close", "\n");
emitStr(&stmts, "", "__sqrt_int\t\tPUSH -3[0]\t\t# push x onto stack", "\n");
emitStr(&stmts, "", "\t\t\tITOR\t\t\t# convert it to a real", "\n");
emitStr(&stmts, "", "\t\t\tPOP -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __sqrt", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__sqrt_real\t\tPUSH -3[0]\t\t# push x onto stack", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __sqrt", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__sqrt\t\t\tCONSTR 0.0\t\t# push 0 onto stack, x now underneath 0", "\n");
emitStr(&stmts, "", "\t\t\tLTR\t\t\t# if x < 0 push 1, else push 0", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __sqrt_err", "\n");
emitStr(&stmts, "", "\t\t\t\t\t\t# x >= 0, if it's 0 let's not waste our time", "\n");
emitStr(&stmts, "", "\t\t\t\t\t\t# computing", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 0.0", "\n");
emitStr(&stmts, "", "\t\t\tEQR", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __sqrt_ret\t\t# if x == 0, we're done, else x > 0 and", "\n");
emitStr(&stmts, "", "\t\t\t\t\t\t# we have work to do", "\n");
emitStr(&stmts, "", "\t\t\tADJUST 2\t\t# make room for # of iters and a on stack", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 10000\t\t", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]\t\t# number of iters <-- 10,000", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 2.0", "\n");
emitStr(&stmts, "", "\t\t\tDIVR", "\n");
emitStr(&stmts, "", "\t\t\tPOP 1[0]\t\t# initial guess for a = x / 2", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __sqrt_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__sqrt_loop\t\tPUSH 0[0]\t\t# push number of iters onto stack", "\n");
emitStr(&stmts, "", "\t\t\tIFZ __sqrt_done\t\t# if == 0, we're done", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tADDI\t\t\t# else, decrement number of iters", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]\t\t# and save it back in its place", "\n");
emitStr(&stmts, "", "\t\t\t", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t\t# push x onto stack", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 1[0]\t\t# push a onto stack", "\n");
emitStr(&stmts, "", "\t\t\tDIVR\t\t\t# top of stack <-- x/a", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 1[0]\t\t# push a onto stack", "\n");
emitStr(&stmts, "", "\t\t\tADDR\t\t\t# top of stack <-- a + (x/a)", "\n");
emitStr(&stmts, "", "\t\t\tCONSTR 2.0\t\t# push 2.0 onto stack", "\n");
emitStr(&stmts, "", "\t\t\tDIVR\t\t\t# top of stack <- (a + (x/a))/2", "\n");
emitStr(&stmts, "", "\t\t\tPOP 1[0]\t\t# a_new <-- stop of stack", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __sqrt_loop", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__sqrt_done\t\tADJUST -2\t\t# get rid of our local variables", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 1[0]\t\t# put a onto stack", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __sqrt_ret", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__sqrt_err\t\t# print error message (write script to help do this stuff)", "\n");
emitStr(&stmts, "", "\t\t\tSTOP", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__sqrt_ret\t\tPOP -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "################################################################################", "\n");
emitStr(&stmts, "", "# __store_string_values() :", "\n");
emitStr(&stmts, "", "# Given an address which points to a contiguous chunk of heap memory of the", "\n");
emitStr(&stmts, "", "# the appropriate size, __store_string_value() stores the values which are ", "\n");
emitStr(&stmts, "", "# currently on the stack to the heap memory chunk.", "\n");
emitStr(&stmts, "", "# Parameters", "\n");
emitStr(&stmts, "", "#\t\t-3[0] : n, the number of values to be stored", "\n");
emitStr(&stmts, "", "#\t\t-4[0] through -(n+4)[0] : the values to be stored on the heap", "\n");
emitStr(&stmts, "", "#\t\t    with the first value highest on the stack.", "\n");
emitStr(&stmts, "", "#\t\t-(n+5)[0] : the base address of the contiguous heap section", "\n");
emitStr(&stmts, "", "################################################################################", "\n");
emitStr(&stmts, "", "__store_string_values", "\n");
emitStr(&stmts, "", "\t\t\tADJUST 1\t# make num of values written to store a ", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# local param, hereby called x", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 0\t# and initialize it to zero", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# now we get the address and make it a local param", "\n");
emitStr(&stmts, "", "\t\t\tADJUST 1", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# push n onto the stack", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tMULI\t\t# top of stack <-- -n", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -4\t# adjust for other params", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPUSHI 0\t\t# push the address onto the stack", "\n");
emitStr(&stmts, "", "\t\t\tPOP 1[0]\t# and save it for later use", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__store_loop", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0] \t# push x onto stack", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]\t# push n onto stack", "\n");
emitStr(&stmts, "", "\t\t\tEQI\t\t# determine if x == n", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __store_done", "\n");
emitStr(&stmts, "", "\t\t", "\n");
emitStr(&stmts, "", "\t\t\t# else, we have more values to print", "\n");
emitStr(&stmts, "", "\t\t\t# push next address onto stack", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 1[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# calculate depth of xth parameter", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tMULI", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -4", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# push xth char onto the stack", "\n");
emitStr(&stmts, "", "\t\t\tPUSHI 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# pop it off to the heap", "\n");
emitStr(&stmts, "", "\t\t\tPOPI", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# set up next iteration", "\n");
emitStr(&stmts, "", "\t\t\t# increment x", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# decrement address", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 1[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP 1[0]", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "\t\t\t# do next iteration", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __store_loop\t", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__store_done\t\t\t", "\n");
emitStr(&stmts, "", "\t\t\t# kick off local params", "\n");
emitStr(&stmts, "", "\t\t\tADJUST -2", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "# ASC implementation of the succ(x) function.", "\n");
emitStr(&stmts, "", "# From the expression x that shall be of an ordinal-type, this function shall", "\n");
emitStr(&stmts, "", "# return a result that shall be of the same type as that of the expression x.", "\n");
emitStr(&stmts, "", "# The function shall yield a value whose ordinal number is one greater than that", "\n");
emitStr(&stmts, "", "# of the expression x, if such a value exists.  It shall be an error if such a ", "\n");
emitStr(&stmts, "", "# value does not exist.", "\n");
emitStr(&stmts, "", "#", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__succ_int\t\tPUSH -3[0]\t# push x onto the stack", "\n");
emitStr(&stmts, "", "\t\t\t# TODO: make sure x < maxint", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1\t# push 1 onto stack", "\n");
emitStr(&stmts, "", "\t\t\tADDI\t\t# top of stack <-- x + 1", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]\t# store x+1 as ret value", "\n");
emitStr(&stmts, "", "\t\t\tRET 0\t\t\t\t", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__succ_int_err\t\t# the integer give was == maxint, cannot get successor", "\n");
emitStr(&stmts, "", "\t\t\tSTOP", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__succ_bool\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __succ_bool_err\t# bool > 0 => no successor", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1\t\t# push 1 onto stack", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]\t\t# make 1 ret value", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__succ_bool_err\t\t# print error message", "\n");
emitStr(&stmts, "", "\t\t\tSTOP", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__succ_char\t\tPUSH -3[0]\t# push x onto stack", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 255\t# push ascii val of '9' onto stack", "\n");
emitStr(&stmts, "", "\t\t\tEQI\t\t# if x == '9', need ret = 'A', else", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# check if x is next boundary value 'Z' ", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __succ_char_err", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 255", "\n");
emitStr(&stmts, "", "\t\t\tGTI", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __succ_char_err\t# char with val >255 => no succ", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP -4[0]", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__succ_char_err \t# no successor", "\n");
emitStr(&stmts, "", "\t\t\tSTOP", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "# For scalar types we get to have even more fun.  Each item in an enumerated", "\n");
emitStr(&stmts, "", "# scalar type is represented internally as a const -- so that's easy to ", "\n");
emitStr(&stmts, "", "# increment.  The bit of extra work is that we need to also pass to succ() the", "\n");
emitStr(&stmts, "", "# largest value amongst the consts in the enumerated type (e.g., the number", "\n");
emitStr(&stmts, "", "# of elements in the enumerated scalara - 1, where we subtract 1 as the", "\n");
emitStr(&stmts, "", "# standard specifies that the values of the constants beings at 0).  This", "\n");
emitStr(&stmts, "", "# \"largest\" value will be passed as the second parameter to __succ_scalar", "\n");
emitStr(&stmts, "", "__succ_scalar\t\tPUSH -3[0]\t# push x onto the stack", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -4[0]\t# push x_max onto the stack", "\n");
emitStr(&stmts, "", "\t\t\t# We should only have to test for equality if we", "\n");
emitStr(&stmts, "", "\t\t\t# are performing error checking correctly elsewhere", "\n");
emitStr(&stmts, "", "\t\t\t# in the program", "\n");
emitStr(&stmts, "", "\t\t\tEQI", "\n");
emitStr(&stmts, "", "\t\t\tIFNZ __succ_scalar_err", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP -5[0]", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "__succ_scalar_err\t# print error message", "\n");
emitStr(&stmts, "", "\t\t\tSTOP", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "# Asc implementation of trunc()", "\n");
emitStr(&stmts, "", "# From the expression x that shall be of real-type, this function shall return", "\n");
emitStr(&stmts, "", "# a result of integerType.  The value of trunc(x) shall be such that if x is", "\n");
emitStr(&stmts, "", "# positive or zero, then 0 < x-trunc(x) < 1; otherwise -1 < x- trunc(x) < 0.", "\n");
emitStr(&stmts, "", "# It shall be an error if such a value does not exist.", "\n");
emitStr(&stmts, "", "# TODO: when can an error occur?", "\n");
emitStr(&stmts, "", "# NOTE: super easy, ROTI does trunc() for us.", "\n");
emitStr(&stmts, "", "__trunc\t\tCONSTI 0", "\n");
emitStr(&stmts, "", "\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\tCALL 0, __is_bad_real", "\n");
emitStr(&stmts, "", "\t\tADJUST -1", "\n");
emitStr(&stmts, "", "\t\tIFNZ __trunc_err", "\n");
emitStr(&stmts, "", "\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\tRTOI", "\n");
emitStr(&stmts, "", "\t\tPOP -4[0]", "\n");
emitStr(&stmts, "", "\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__trunc_err\t# print err mesg", "\n");
emitStr(&stmts, "", "\t\tSTOP", "\n");
emitStr(&stmts, "", "# ASC implementation of write().", "\n");
emitStr(&stmts, "", "# HOW TO CALL:", "\n");
emitStr(&stmts, "", "#\t-> For ints/reals, simply push param as usual and call.", "\n");
emitStr(&stmts, "", "#\t-> For chrs/string, push number of chars to print as first param", "\n");
emitStr(&stmts, "", "#\t    (i.e., at -3[0]), we then print the last param first (so ", "\n");
emitStr(&stmts, "", "#\t    just throw everything onto the stack in the order you get it,", "\n");
emitStr(&stmts, "", "#\t    then push number of params to print and then call write)", "\n");
emitStr(&stmts, "", "__write_str\t\tADJUST 1\t# make number of args a local param", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __write_str_loop", "\n");
emitStr(&stmts, "", "__write_str_loop\tPUSH 0[0]\t# top of stack <-- # left to print", "\n");
emitStr(&stmts, "", "\t\t\tIFZ __write_str_end\t# nothing more to print, exit", "\n");
emitStr(&stmts, "", "\t\t\t# else we have a char to write", "\n");
emitStr(&stmts, "", "\t\t\t# start by calculating depth of 0[0]th param", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tMULI\t\t", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -3", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPUSHI 0\t\t# push next char onto stack", "\n");
emitStr(&stmts, "", "\t\t\tWRITEC\t\t# write the character", "\n");
emitStr(&stmts, "", "\t\t\t# decrement # of args", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __write_str_loop", "\n");
emitStr(&stmts, "", "__write_str_end\t\tADJUST -1\t# kick local vars off the stack", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__write_int\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tWRITEI", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__write_real\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tWRITER", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "# ASC implementation of writeln.", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__writeln_str\t\tADJUST 1\t# make number of args a local param", "\n");
emitStr(&stmts, "", "\t\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __writeln_str_loop", "\n");
emitStr(&stmts, "", "__writeln_str_loop\tPUSH 0[0]\t# top of stack <-- # left to print", "\n");
emitStr(&stmts, "", "\t\t\tIFZ __writeln_str_end\t# nothing more to print, exit", "\n");
emitStr(&stmts, "", "\t\t\t# else we have a char to write", "\n");
emitStr(&stmts, "", "\t\t\t# start by calculating depth of 0[0]th param", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tMULI\t\t", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -3", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPUSHI 0\t\t# push next char onto stack", "\n");
emitStr(&stmts, "", "\t\t\tWRITEC\t\t# write the character", "\n");
emitStr(&stmts, "", "\t\t\t# decrement # of args", "\n");
emitStr(&stmts, "", "\t\t\tPUSH 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI -1", "\n");
emitStr(&stmts, "", "\t\t\tADDI", "\n");
emitStr(&stmts, "", "\t\t\tPOP 0[0]", "\n");
emitStr(&stmts, "", "\t\t\tGOTO __writeln_str_loop", "\n");
emitStr(&stmts, "", "__writeln_str_end\tADJUST -1\t# kick local vars off the stack", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 10\t# we're writeln, so we write newchar", "\n");
emitStr(&stmts, "", "\t\t\t\t\t# before we go away", "\n");
emitStr(&stmts, "", "\t\t\tWRITEC", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__writeln_int\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tWRITEI", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 10", "\n");
emitStr(&stmts, "", "\t\t\tWRITEC", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
emitStr(&stmts, "", "__writeln_real\t\tPUSH -3[0]", "\n");
emitStr(&stmts, "", "\t\t\tWRITER", "\n");
emitStr(&stmts, "", "\t\t\tCONSTI 10", "\n");
emitStr(&stmts, "", "\t\t\tWRITEC", "\n");
emitStr(&stmts, "", "\t\t\tRET 0", "\n");
emitStr(&stmts, "", "", "\n");
}
